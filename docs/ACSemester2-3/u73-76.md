---
sidebar_position: 21
---


# U73-76 技術和新知

## Syntactic Sugar
1. Syntactic 是指與程式語言語法相關的，而Sugar則是比喻透過程式語法來將一個程式模組包裝成一個易讀好維護的語法形式-糖衣。
2. 包裝前和包裝後的功能是一樣，只是差別在於可以讓開發者可以使用更貼近(sweeter)人類的語法：人類可以更好理解、更精準地開發、很好維護的語法
### 參考資料
1. [什么是语法糖？](https://www.zhihu.com/question/20651624)
2. [Syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar)



## model 和 document 在 mongoose中
1. model 和 document 本身是不一樣的物件類別


## todolist 案例下的路由設計
1. 理想下的路由設計：
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638262176/blog/srello/idealRouteDesign_a2ttbi.png)

2. 但由於HTML本身對於PUT和Delete的支援性不高，實際上的路由設計會是：
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638262176/blog/srello/realRouteDesign_ejwpxb.png)

## todolist 瀏覽所有todo的實作
1. 滿足該瀏覽所有todo的路由會是如下，只要瀏覽根目錄就能即可能瀏覽每個todo
```
GET /
```
2. 實際下MVC架構會是如何做：
  - 客戶端發送 GET / 的請求
  - 伺服器收到 GET / 的請求，並到路由清單尋找與 GET / 請求相符的路由，執行該路由的Controller
  - 該Controller 向 Model-todoModel 發出獲取對應collection的所有資料之請求
  - Model 透過 Mongoose 的幫助下，向MongoDB資料庫發出Query請求
  - MongoDB 資料庫回傳資料
  - Model - todoModel 再將資料轉送給Controller 
  - Controller 再將資料轉接給View引擎(handlebars)，要求渲染GET /對應的頁面，並加入Model轉交過來的資料
  - View 引擎工作完成後，並把合併後的HTML模板網頁回傳給Controller
  - Controller 再將合併後的模板網頁回傳給客戶端
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638283689/blog/srello/viewAlltodos_tv7doh.png)

3. 在這裡MVC負責以下工作：
  - Controller：路由清單尋找與 GET / 請求相符的路由，執行該路由的Controller、該Controller 向 Model-todoModel 發出獲取對應collection的所有資料之請求
  ```
  // 載入Model模組，取得對應collection的document constructor
  const todoModel = require('./models/todoModel')
  app.get('/', (req, res) => {

  // 藉由document constructor所擁有的方法-find來對對應的collection建立特定資料搜查的請求(Query)
  //，而由於沒有參數會直接從collection取得所有資料，最後todoModel.find()本身回傳為代表搜查請求Query

  // Controller 向 Model-todoModel 發出獲取對應collection的所有資料之請求
  todoModel.find()
  
  // 要求Query最後執行的結果格式轉化成handlebars能夠接收的格式
    .lean()
  // 以Promise形式來執行Query，換言之，Model 透過 Mongoose 的幫助下，向MongoDB資料庫發出Query請求
    .exec()

  // 當執行完Promise之後，當搜尋成功，其todos會是Query執行後的搜尋結果，接著用它來對index
  // 這渲染檔案和搜尋結果合併渲染

  // Controller 再將資料轉接給View引擎(handlebars)，要求渲染GET /對應的頁面，
  // 並加入Model轉交過來的資料，View 引擎工作完成後，並把合併後的HTML模板網頁回傳給
  // Controller
    .then(todos => res.render('index', { todos }))
  // 當搜尋失敗，就以eror物件來回傳搜尋失敗後得到的錯誤訊息
    .catch(error => console.log(error))

  })
  ```
  
  - Model： 在這裏負責接收Controller的請求來在對應集合中找到所有資料、向 MongoDB 資料庫發出 query 請求、當MongoDB 資料庫回傳資料時，再由Model把資料回傳給Controller，該Model設定內容如下，但實際上執行的地方是在Controller的路由系統中，由Controller調用著Model。

  ```
  // 載入mongoose 套件
  const mongoose = require('mongoose')
  
  // 在應用程式層面定義collection的schema
  const Schema = mongoose.Schema
  const todoSchema = new Schema({
  name: {
    type: String, // 資料型別是字串
    required: true // 這是個必填欄位
  }
  })

  // 在指定的資料庫當中建立名為todos的collection，並且回傳以Schema作為內容
  // 儲存限制 之 document constructor，最後以模組內容來輸出，只要有人以目前
  // 所在檔案為模組，該模組內容將會是mongoose.model(....)
  module.exports = mongoose.model('todo', todoSchema)
  ```


  - view：在這裏負責接收Controller的請求和資料來將資料和對應請求的模板網頁做合併、回傳合併後的模板網頁給Controller，該模板網頁內容如下：

  ```
  <h2>Hello world! 這是 index</h2>

  <a href="./todos/new">Create</a>
  <ul>
    {{#each todos}}
    <li>
      {{this.name}}
      <a href="./todos/{{ this._id }}">detail</a>
      <a href="./todos/{{ this._id }}/edit">edit</a>
      <form action="./todos/{{ this._id }}/delete" method="POST" style="display: inline;">
        <button type="submit">delete</button>
      </form>
    </li>
    {{/each}}
  </ul>

  ```

## todolist 瀏覽特定todo的實作
1. 滿足該瀏覽特定todo的路由會是如下，其中會以/todos/為篩選條件來取得後面的字串作為特定todo的id
```
GET /todos/:id
```
2. 實際下MVC架構會是如何做：
  - 客戶端發出 GET /todos/:id 的請求
  - 伺服器收到請求，並到路由清單找尋對應 GET /todos/:id 的 Controller 來處理請求
  - 該Controller 會從請求中取出:id的部分作為某個todo的id
  - Controller 向 Model - todoModel 發出找尋符合id的資料之請求Query
  - Model 透過 Mongoose 的幫助下，向MongoDB資料庫發出Query請求
  - 當資料庫回傳指定結果給Model時，Model會將資料轉交給Controller
  - Controller 再向View引擎(handlebars)發出對應請求的渲染畫面，並加入至Model轉交過來的資料
  - View收到資料後，便將資料和對應模板網頁做合併，最後將合併後的模板網頁傳至Controller
  - Controller 再將合併後的模板網頁傳至客戶端。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638283689/blog/srello/viewAtodo_mhculs.png)


3. 在這裡MVC負責以下工作：
  - Controller：路由清單尋找與 GET /todos/:id 請求相符的路由，執行該路由的Controller、獲取請求中的id、該Controller 向 Model-todoModel 發出獲取對應collection且能夠滿足id的資料之請求

  ```

  // 載入程式模組，取得對應collection的document constructor
  const todoModel = require('./models/todoModel')
  app.get('/todos/:id', (req, res) => {

  // 則是從/todos/:id取得:id來作為特定todo的Id
  const reqId = req.params.id
  // 藉由document constructor所擁有的方法-find來對對應的collection建立特定資料搜查的請求(Query)
  //，而由於沒有參數會直接從collection取得所有資料，最後todoModel.findById(reqId)本身回傳為代表
  // 搜查請求Query

  // Controller 向 Model - todoModel 發出找尋符合id的資料之請求Query
  todoModel.findById(reqId)
  
  // 要求Query最後執行的結果格式轉化成handlebars能夠接收的格式
    .lean()
  // 以Promise形式來執行Query，換言之，Model 透過 Mongoose 的幫助下，向MongoDB資料庫發出Query請求
    .exec()
  // 當執行完Promise之後，當搜尋成功，其todo會是Query執行後的搜尋結果，接著用它來對detail


  // 當資料庫回傳指定結果給Model時，Model會將資料轉交給Controller，Controller 再向View引擎
  // (handlebars)發出對應請求的渲染畫面，並加入至Model轉交過來的資料
    .then(todo => res.render('detail', { todo }))
  // 當搜尋失敗，就以eror物件來回傳搜尋失敗後得到的錯誤訊息
    .catch(error => console.log(error))

  })
  ```
  
  - Model：在這裏負責接收Controller的請求來在對應集合中找到滿足id資料、向 MongoDB 資料庫發出 query 請求、當MongoDB 資料庫回傳資料時，再由Model把資料回傳給Controller，該Model設定內容如瀏覽所有todo的內容相同，但實際上執行的地方是在Controller的路由系統中，由Controller調用著Model。

  - view：在這裏負責接收Controller的請求和資料來將資料和對應請求的模板網頁做合併、回傳合併後的模板網頁給Controller，該模板網頁內容如下：

  ```
  <p>{{ todo.name }}</p>
  <a href="/todos/{{ todo._id }}/edit">edit</a>
  <a href="/">back</a>
  <form action="/todos/{{ todo._id }}/delete" method="POST" style="display: inline;">
    <button type="submit">delete</button>
  </form>
  ```


## todolist 建立特定todo的實作
1. 要完成這個實作，會有兩個請求方向，一種是導向負責建立todo頁面的請求，接著第二種是接續著第一種來定義在建立頁面下發送增加資料的請求：
  - 導向負責建立todo頁面的請求：通常會有這請求是因為使用者所處的頁面並非是建立頁面，所以使用者必須發送導向其頁面的請求：
  ```
  get /todos/new
  ```

  - 在建立頁面下發送增加資料的請求：當使用者處在建立頁面上，而該頁面上通常會是由表格來接收使用者所輸入的內容來新增資料，在這裡並不會有任何:id的請求，因此直接設定成如下：
  ```
  post /todos
  ```
2. 實際下MVC架構會是如何做：
  - 導向負責建立todo頁面的請求：當路由系統接收到GET /todos/new請求時，Controller會從View模組取得對應的模組網頁並回傳給Controller，由它轉交給客戶端做渲染
  ![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638284242/blog/srello/direct2CreatePage_bshlqy.png)

  - 在建立頁面下發送增加資料的請求：當路由系統接收到POST /todos請求時，Controller會解析POST封包的內容，並向Model模組根據內容來發送新增資料至資料庫的請求，Model模組收到後，便幫忙新增資料至資料庫，接著回傳處理結果告知Controller模組已完成，然後再由Controller模組請求客戶端導向首頁。
  ![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638284242/blog/srello/createATodo_rxv3k8.png)
3. 在這裡MVC負責以下工作：
  - 導向負責建立todo頁面的請求：在這裡只會有Controller和View負責處理，Controller會負責接收GET /todos/new，接著它會間接呼叫View模組中的渲染引擎去獲取new這渲染檔案，接著由引擎回傳結果，最後再由Controller 以res的形式回傳給客戶端，這裏View所提供的內容為一個包含提交按鈕和輸入欄的表格，當使用者按下提交按鈕就發送POST請求至/todos

  ```
  // Controller 內容
  // 定義Controller 接收到 GET /todos/new所要做的處理
  app.get('/todos/new', (req, res) => {
  res.render('new')
  })

  // Views 內容：
  // 定義GET /todos/new請求所要獲取的畫面，並以名為new的渲染檔案來儲存。
  // 其內容包含一個提交按鈕和一個輸入欄的表格，當使用者按下提交按鈕就發送POST請求至/todos
  <form action="/todos" method="POST">
    <input type="text" placeholder="name" name="name">
    <button type="submit">Create</button>
  </form>
  ```

  - 在建立頁面下發送增加資料的請求：在這裡只會有Controller和Model負責處理資料增加的請求，Controller會負責接收POST /todos請求，接著它就解析POST封包內容是什麼，然後將該內容來轉傳給Model-todoModel，讓它去建立一個儲存該內容的Document Instance，接著再讓Model透過save()來讓Instance以文件的形式儲存在對應的collection中，當資料庫完成工作時，Model再進一步檢查是否真的完成工作，若真的成功增加，則發出請求客戶端導向首頁，若真的失敗，則印出錯誤訊息。
  ```
  // Controller 內容，在這裏todoModel即為Model所提供，當使用它便是代表向它發出請求來處理資料增加
  // add a new todo
  app.post('/todos', (req, res) => {
    // 解析POST封包內容
    const name = req.body.name
    // 根據封包內容來建立Document Instance的內容
    const newTodo = new todoModel({ name })


    // 將Document Instance以文件形式增加至對應的collection，會save本身會回傳Promise，
    // 進而控制後續的then和catch
    return newTodo.save()
    // 當增加成功的話，就請求客戶端轉向首頁
      .then(res.redirect('/'))
    // 當增加失敗的話，就印出錯誤訊息
      .catch(error => console.log(error))

  })
  ```