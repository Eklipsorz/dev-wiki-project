---
sidebar_position: 19
---

# U67-73 技術和新知


## Database Seeding
1. 又名為Seeding a database，
2. Seeding本身是播種行為，先將土播開來騰出放種子的空間，然後把種子存放進去，然後再利用騰出來的土把騰出的空間填平，其中播種的第一個行為是將土播開騰出空間
3. 在資料庫中，播種的 "種" 是指要放入資料庫的資料，而播種的播則是將騰出資料庫的空間來存放種子(資料)，兩者加起來就是將騰出資料庫的空間存放資料，即資料庫存放資料，而至於會採用播種這詞，是因為資料庫可以基於這資料而衍生其他資料或者衍生出其他功能，也就是將其比喻為播種後的開花結果。
4. 統整2.3點來說的話，播種的種通常會是資料庫剛一建立後會有的資料，而兩個字合在一起就是儲存資料庫剛開始的資料，資料庫可以透過這份資料來衍生其他服務或者其他資料。
5. 初始資料被稱之為種子資料(Seed data)，負責產生初始資料並放入資料庫的程式叫做seeder，本身用途就是產生種子資料好建立網路應用程式的基本元件，比如選單上的預設項目

## mongoose buffering mechanism
1. 該機制是當mongoose對於mongoDB的連線是失敗的時候，會暫存所有未執行完的資料庫指令，而資料庫指令是指mongoose封裝資料庫指令的函式，等到連線成功時，就執行所有未執行完的資料庫指令。
2. 預設下，mongoose會支援，若不想要讓mongoose出現這機制可以將mongoose的系統變數bufferCommands設為false，在這情況下，斷連後重新連線會以當時收到的指令來執行，而非以過去出現的指令，而若是true的話，會是出現這機制
```
const mongoose = require('mongoose')
mongoose.set('bufferCommands', false);
```
3. 若支援此機制，下面兩者都會是一樣的，find在這裡等同於可以操作資料庫的指令，而第一個例子的find是在connect之前，正常情況下，會先對資料庫進行連線才能開始對資料庫進行操作，但在這裡，mongoose會先暫存find指令，等到系統執行connect並連線成功時，mongoose就會執行暫存的指令-find，而第二個例子的find則是在connect之後才進行操作，屬於正常操作指令

```
const mongoose = require('mongoose')
const model = require('dbmodel')
model.find()        // mongoose封裝資料庫指令的函式
mongoose.connect(`mongodb://localhost:${dbPort}/${dbName}`)
```

```
const mongoose = require('mongoose')
const model = require('dbmodel')
mongoose.connect(`mongodb://localhost:${dbPort}/${dbName}`)
model.find()        // mongoose封裝資料庫指令的函式
```
4. 涉及buffering mechanism的mongoose指令有find、model

## buffer mechanism 與 model 的關係
1. 當關閉buffer mechanism時，model方法不論是否放在connect之前或者之後，都會因為收到連線成功的訊息延遲而無法即時執行，最後無法產生對應的collection。
```
const mongoose = require('mongoose')
mongoose.set('bufferCommands', false);

// way 1：當model放在connect之前，結果未成功建立名為name的collection在資料庫

mongoose.model(name, schema)
mongoose.connect(....)

// way 2：當model放在connect之後，結果未成功建立名為name的collection在資料庫
mongoose.connect(....)
mongoose.model(name, schema)
```

2. 若把model方法放在定時器的話，讓它延遲到能接收成功連線並能執行model的時候，就會成功在資料庫建立起名為settimeouts的collection，另外之所以全以小寫和後面加s是mongoose自動轉換成小寫和加s

```
setTimeout(() => {
  const Schema = mongoose.Schema
  const todoSchema = new Schema({
    name: {
      type: String, // 資料型別是字串
      required: true // 這是個必填欄位
    }
  })

  mongoose.model('cseasd', todoSchema)
  console.log('completed')
}, 5000)
```
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637591244/blog/database/setTimeOutModel_kjdli9.png)

3. 若把model放在資料庫的open事件的話，就能在資料庫回報成功連線的時候，建立起名為dbopens的collection在資料庫中

```
const db = mongoose.connection 

db.once('open', () => {

  const Schema = mongoose.Schema
  const todoSchema = new Schema({
    name: {
      type: String, // 資料型別是字串
      required: true // 這是個必填欄位
    }
  })

  mongoose.model('cseasdwea', todoSchema)
  console.log('completed')
  console.log('mongodb connected!')
})
```

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637591244/blog/database/dbOpenModel_mhuxow.png)

### 參考資料
1. [option: bufferCommands](https://zhuanlan.zhihu.com/p/43559398)
2. [what is bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands)

## MVC架構中的Model實作
1. 若採用資料庫上的資料進行網路應用程式的開發，會將負責儲存和管理資料庫的程式碼分割出models這目錄，其中models之所以添加s，是因為負責管理的資料不止於一個資料庫，可能會涉及更多的資料庫，另外models還會存放一個名為seeds的子目錄來存放種子資料和負責產生種子資料的程式，因此會加上s
2. 整體來說，models所在的目錄會是如下，models會是跟views、app.js處在同一個階層的目錄，而models會存放著負責管理/存取資料庫的程式碼、種子資料相關的程式碼，其中srelloList.js是負責存取資料庫的程式，而seeds則是存放種子資料相關程式碼的子目錄，裡頭存放著srelloListSeeder.js這負責產生種子資料和將種子資料存放至資料庫的程式。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637575686/blog/database/realModelsPos_megfvb.png)

## 編譯
1. 英文為Compile，中文意思為從不同地方收集資訊並整理成一本書、一份報告或者一份清單，或者引申為轉變，在電腦程式語言中，編譯是指著某種程式語言寫成的程式碼轉換另一個程式語言形式的程式碼。

## 建構子
1. 英文為Constructor，中文意思為負責建立某項東西的另一個東西，在程式語言中，是負責按照物件導向語言的class類別來產出對應的實體(Instance)物件之函式，換言之，透過這個函式可以建立特定類別的實體物件，而這個實體物件會跟特定類別所標示的那樣。
2. 而class本身是製造特定物品或者物件的藍圖，本身會定義特定物品或者物件的屬性和方法，屬性就是這個物品/物件會有的特性，或者進一部描述該物品/物件，而方法則是描述這個物品/物件會有的行為和動作，每一個class都會搭配著constructor來方便程式按照class類別來打造屬性、方法和class類別一致的實體物件。

## 管理/存取資料庫的程式碼
1. 該程式碼目的是負責整個應用程式的資料庫存取，程式中的每個部分若想要存取資料庫都必須經由該程式碼，從而達到維護和關注點分離
2. 在這裏的案例中，MongoDB是資料庫，而Mongoose是資料庫的ODM，該ODM會在負責存取資料庫的程式碼進行調用，而程式碼會存放在models中(如下圖所示)，在這裏區分幾個步驟：引用mongoose模組賦予mongoose變數、透過mongoose來引用mongoose對於Schema的建構子並賦予至Schema變數、透過new和指定的建構子建立一個Schema來方便讓mongoose管理MongoDB的集合、利用mongoose.model將Schema綁定在一個名稱並編譯成一個model、匯出該model給他人使用。
```
const mongoose = require('mongoose')
const Schema = mongoose.Schema
const todoSchema = new Schema({
  name: {
    type: String, // 資料型別是字串
    required: true // 這是個必填欄位
  }
})
module.exports = mongoose.model('name', todoSchema)
```

3. 引用mongoose模組賦予mongoose變數：
```
const mongoose = require('mongoose')
```

4. 透過mongoose來引用mongoose對於Schema的建構子並賦予至Schema變數
```
const Schema = mongoose.Schema
```
5. 透過new和指定的建構子來建立一個Schema來方便讓mongoose管理MongoDB的集合，而Schema內容是指定資料庫每一筆資料的屬性、型別、額外限制，在這裡會是定義每一筆資料會有名為name的屬性，而型別為字串且必須要填寫，另外new Schema中的Schema會跟第四步驟的Schema相關，若第四步驟的const Schema是const apple，那麼在這裡必須調用的建構子是new apple({})
```
const todoSchema = new Schema({
  name: {
    type: String, // 資料型別是字串
    required: true // 這是個必填欄位
  }
})
```


6. 利用mongoose.model將Schema綁定在一個名稱並編譯成一個model並匯出該model給他人使用，在這裡mongoose.model會在連線成功時取得對應的資料庫，並且以todoSchema所定義的Schema來當作名為names的collection，最後封裝(編譯)成一個model來對應這個collection，另外真實在資料庫中的collection名稱並不會是以name為主，而是以names，這是因為mongoose會強制將名稱轉換全小寫和後面加s，最後只要對著這個model進行操作，就等同對那個collection進行相同的操作，最後再以module.exports來當作目前模組的內容來匯出
```
module.exports = mongoose.model('name', todoSchema)
```


## mongoose.model
1. mongoose模組物件會有的方法
2. 根據schema來真實在資料庫建立指定名稱的collection，並且封裝(編譯)該collection成model來讓應用程式端透過它來操控對應的collection，也就是說只要對model進行操作，其對應的collection就會跟著變動。

3. 其形式會是如下，會真實根據todoSchema來在資料庫建立名為names的collection，並以model的形式來封裝(編譯)該collection來回傳，其collection的資料會受限於todoSchema所規定的那樣，而之所以collection是names，而非name，乃是因為mongoose會強制將名稱轉換成全小寫和檢查名稱後面是否有加s，若沒加s就額外添加s
```
mongoose.model('name', todoSchema)
```

4. 當如果重複呼叫mongoose.model時，除了第一次只是建立collection和回傳model以外，後續的mongoose.model只會根據collection的名稱來找到對應collection並將以model形式回傳
```
mongoose.model('name', todoSchema)
mongoose.model('name', todoSchema)
```


## 種子資料相關的程式碼
1. 該程式碼目的是負責建立種子資料在資料庫，好讓資料庫或者服務透過它來正常運作，該程式碼通常會放在models/seeds中，其檔名會有seeder
2. 在這裡的案例會建立十筆資料放在srelloListModel所對應的collection，而這十筆資料正是種子資料，流程分為：與指定資料庫進行連線並建立對應collection的model、監聽資料庫的連線狀態、設定當成功連線時所需要做的種子資料生成
```
const dbPort = 27017
const dbName = 'srello-list'

const mongoose = require('mongoose')
const srelloListModel = require('../srelloList')
mongoose.connect(`mongodb://localhost:${dbPort}/${dbName}`)

// get connection between mongodb and mongoose
const db = mongoose.connection

// 
db.on('error', () => {
  console.log('mongodb error!')
})

db.once('open', () => {
  console.log('mongodb connected!')

  for (let index = 0; index < 10; index++) {
    srelloListModel.create({ name: `name-${index}` })
  }
  console.log('done.')
})
```

3. 與指定資料庫進行連線並建立對應collection的model，其中srelloListModel就是model
```
const dbPort = 27017
const dbName = 'srello-list'

const mongoose = require('mongoose')
const srelloListModel = require('../srelloList')
mongoose.connect(`mongodb://localhost:${dbPort}/${dbName}`)
```

4. 監聽資料庫的連線狀態
```
// get connection between mongodb and mongoose
const db = mongoose.connection

// 
db.on('error', () => {
  console.log('mongodb error!')
})

db.once('open', () => {
  .....
})
```


5. 設定當成功連線時所需要做的種子資料生成，在這裡會使用for迴圈來執行十次的特定程式，而特定程式則是model的create方法，這指令會在對應的collection中按照指定屬性來產生出一筆name屬性為name-index的資料，最後會有十筆

```
db.once('open', () => {
  console.log('mongodb connected!')

  for (let index = 0; index < 10; index++) {
    srelloListModel.create({ name: `name-${index}` })
  }
  console.log('done.')
})
```





## model.create
1. 為mongoose.model.create的方法
2. 會在model對應的collection建立一筆資料，而資料格式會由Document object來決定，而該物件的屬性得按照model對應的schema來填寫，若在Document添加未在schema出現的屬性，則其屬性不會被添加，只留下存在schema所指定的屬性

```
model.create(Document)

// Document = {
  key1: value1,
  key2: value2,
    .
    .
  keyn: valuen
}
```

