---
sidebar_position: 19
---

# U67-73 技術和新知


## Database Seeding
1. 又名為Seeding a database，
2. Seeding本身是播種行為，先將土播開來騰出放種子的空間，然後把種子存放進去，然後再利用騰出來的土把騰出的空間填平，其中播種的第一個行為是將土播開騰出空間
3. 在資料庫中，播種的 "種" 是指要放入資料庫的資料，而播種的播則是將騰出資料庫的空間來存放種子(資料)，兩者加起來就是將騰出資料庫的空間存放資料，即資料庫存放資料，而至於會採用播種這詞，是因為資料庫可以基於這資料而衍生其他資料或者衍生出其他功能，也就是將其比喻為播種後的開花結果。
4. 統整2.3點來說的話，播種的種通常會是資料庫剛一建立後會有的資料，而兩個字合在一起就是儲存資料庫剛開始的資料，資料庫可以透過這份資料來衍生其他服務或者其他資料。
5. 初始資料被稱之為種子資料(Seed data)，負責產生初始資料並放入資料庫的程式叫做seeder，本身用途就是產生種子資料好建立網路應用程式的基本元件，比如選單上的預設項目

## mongoose buffering mechanism
1. 該機制是當mongoose對於mongoDB的連線是失敗的時候，會暫存所有未執行完的資料庫指令，而資料庫指令是指mongoose封裝資料庫指令的函式，等到連線成功時，就執行所有未執行完的資料庫指令。
2. 預設下，mongoose會支援，若不想要讓mongoose出現這機制可以將mongoose的系統變數bufferCommands設為false，而若是true的話，會是出現這機制
```
const mongoose = require('mongoose')
mongoose.set('bufferCommands', false);
```
3. 若支援此機制

```
const mongoose = require('mongoose')

```




## MVC架構中的Model實作
1. 若採用資料庫上的資料進行網路應用程式的開發，會將負責儲存和管理資料庫的程式碼分割出models這目錄，其中models之所以添加s，是因為負責管理的資料不止於一個資料庫，可能會涉及更多的資料庫，另外models還會存放一個名為seeds的子目錄來存放種子資料和負責產生種子資料的程式，因此會加上s
2. 整體來說，models所在的目錄會是如下，models會是跟views、app.js處在同一個階層的目錄，而models會存放著負責管理/存取資料庫的程式碼、種子資料相關的程式碼，其中srelloList.js是負責存取資料庫的程式，而seeds則是存放種子資料相關程式碼的子目錄，裡頭存放著srelloListSeeder.js這負責產生種子資料和將種子資料存放至資料庫的程式。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637575686/blog/database/realModelsPos_megfvb.png)

## 編譯
1. 英文為Compile，中文意思為從不同地方收集資訊並整理成一本書、一份報告或者一份清單，或者引申為轉變，在電腦程式語言中，編譯是指著某種程式語言寫成的程式碼轉換另一個程式語言形式的程式碼。

## 建構子
1. 英文為Constructor，中文意思為負責建立某項東西的另一個東西，在程式語言中，是負責按照物件導向語言的class類別來產出對應的實體(Instance)物件之函式，換言之，透過這個函式可以建立特定類別的實體物件，而這個實體物件會跟特定類別所標示的那樣。
2. 而class本身是製造特定物品或者物件的藍圖，本身會定義特定物品或者物件的屬性和方法，屬性就是這個物品/物件會有的特性，或者進一部描述該物品/物件，而方法則是描述這個物品/物件會有的行為和動作，每一個class都會搭配著constructor來方便程式按照class類別來打造屬性、方法和class類別一致的實體物件。

## 管理/存取資料庫的程式碼
1. 該程式碼目的是負責整個應用程式的資料庫存取，程式中的每個部分若想要存取資料庫都必須經由該程式碼，從而達到維護和關注點分離
2. 在這裏的案例中，MongoDB是資料庫，而Mongoose是資料庫的ODM，該ODM會在負責存取資料庫的程式碼進行調用，而程式碼會存放在models中(如下圖所示)，在這裏區分幾個步驟：引用mongoose模組賦予mongoose變數、透過mongoose來引用mongoose對於Schema的建構子並賦予至Schema、透過new和指定的建構子建立一個Schema來方便讓mongoose管理MongoDB的集合、利用mongoose.model將Schema綁定在一個名稱並編譯成一個model、匯出該model給他人使用。
```
const mongoose = require('mongoose')
const Schema = mongoose.Schema
const todoSchema = new Schema({
  name: {
    type: String, // 資料型別是字串
    required: true // 這是個必填欄位
  }
})
module.exports = mongoose.model('collection', todoSchema)
```


首先該程式碼會是如下所示：首先會先調用mongoose模組至一個變數，接著再透過他的建構子(函式)mongoose.Schema，該建構子本身是個函式物件，所以賦予給Schema時，當要執行對應的建構功能，就只能將Schema當作建構子本身並透過new這關鍵字來按照mongoose.Schema所設計的實體藍圖來打造一個Schema實體，而該實體會是能定義

若將mongoose.Schema賦予給其他變數的話，比如todoSchema，那麼建構子

