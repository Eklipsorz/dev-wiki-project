---
sidebar_position: 14
---


# U54 技術和新知


## Percent-encoding
1. 為了使URL形式在全世界都能夠正確被辨識而將全世界的語言編碼系統統一成一個編碼系統，而這個編碼系統就是Percent-encoding，由於本身是因為為了統一URL的形式而提出的，所以又能稱之為URL encoding。
2. 該編碼擁有著固定數量可辨識的字元，並且會將全世界的語言形式映射在這些可辨識的字元，從而解決各個網頁服務不受編碼系統的種類而影響
3. 該編碼本身具有三種形式可辨識的字元，保留字元(Reserved characters)、未保留字元(Unreserved characters)、百分比字元(Percent character)：
    - 保留字元(Reserved characters)：在編碼系統中，這些字元具有特定用途，並不能夠完全當作URL的本身，所以為了確保用途能夠正常使用而保留給編碼系統用
    - 未保留字元(Unreserved characters)：在編碼系統中，是用來構成URL字串的基本字元
    - 百分比字元(Percent character)：在編碼系統中，將其他編碼系統轉換成URL形式的編碼結果，而結果通常會是%開頭

4. 編碼規則：官方編碼方式是將電腦不能直接辨識的字元轉換成UTF-8形式，然後再搭配%來構成新的形式，形式會如下，xx會是取用UTF-8轉換後的序列中前兩個16進制號碼，當號碼較多時，則將後面的號碼來搭配%從而構成第二種形式，甚至是第三種。
```
%xx
%xx%xx
%xx%xx%xx
```

5. 例子："" 在UTF-8可轉換為兩個字元組，分別為16進制下的C3A7，那麼在Percent encoding的結果會是
```
%c3%a7
```

### 參考資料
1. [URI encoding programs](https://www.w3.org/International/O-URL-code.html)


## body parser
1. 由於post是將資料存放於封包上的message body上，而不是像get那麼直接就把資料放在URL，而express在4.17.1以前並沒有一個好方法能夠方便取得post傳遞過來的資料，因此使用者必須使用body parser這套件來方便擷取，隨後4.17.1之後就內建了該套件來讓express能夠方便擷取post的資料。

2. body-



## Middleware in express.js
1. 該Middleware在node.js/express.js中會是夾雜在request/response cycle之間的程式碼模組，也就是下圖中的Middleware，request 則是客戶端發送的請求，而response則是客戶端請求所要的回應或者功能，request/response cycle則是發送特定請求n和回應特定請求n之間的處理過程，當客戶端發送請求n至伺服器時，便開始該請求的cycle，而當伺服器回應該請求後，就便結束了該請求的cycle。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636120588/blog/middleware/req_res_middleware_ml8hxi.png)
2. Middleware 由於夾雜在 request 和 response 之間，所以可以存取分別代表request和response的物件。
3. 根據用途，express.js 的 Middleware 根據用途分為：
 - 應用程式種類： app.use
 - 路由種類：router.use
 - 內建通用：express.static, express.json, express.urlencoded
 - 錯誤處理種類：app.use(err, req, res, next)
 - 第三方種類(由第三方所提供的Middleware)：bodyparser, cookieparser

## app.use
1. 應用程式種類的Middleware，當目前請求的URL是和app.use所需的URL呈現一致的時候，會執行特定的middleware function
2. app.use 語法形式會是： path 是要匹配且為相對路徑的URL，而 callback 則是呈現一致時所要執行的middleware function
```
app.use(path, callback)
```






### 參考資料
1. [How Node JS middleware Works?](https://selvaganesh93.medium.com/how-node-js-middleware-works-d8e02a936113)

## Middleware function
1. Middleware 代表兩個對象之間的程式碼模組，function則是函式，組合再一起就是夾雜兩個對象之間的函式
2. Middleware 對於請求的回應，通常會是由多個 Middleware function 所組成並協同完成請求，每個Middleware function都因為同為Middleware而能共享於代表request和response的物件。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636123665/blog/middleware/multipleMiddlewareFunction_eyk4ub.png)

3. 每個Middleware function都能執行next()來調用下一個Middleware function 或者 結束cycle 並當成回應來回傳客戶端的請求，通常每個 Middleware Function 都會把自己的輸出處理結果當作是下一個 Middleware function 的輸入參數來處理，最後再由宣布結束cycle的函式來回傳最後的結果

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636124064/blog/middleware/twoCasesMiddlewareFunctions_okwbxj.png)

4. 整體來說，每個Middleware function會呈現一個會維持queue的狀態來等待上一個function將控制權轉交。

5. 如果目前的Middleware function沒執行next()或者沒結束cycle的話，有可能會讓客戶端保持著等請求回應的狀態

## 實際使用Middleware Function
1. 實現能執行next()來調用下一個Middleware function的Middleware function會是以下形式，req和res分別為代表請求request和請求回應response這兩個物件，而next是指向函式物件的參數，系統會根據同種Middleware的function先後順序來自動決定，從最先辨識到的function來先執行，而當你在funct1中的某一段放入next()的話，系統執行到那段便會由funct1呼叫另一個Middleware function，而該Middleware function由於共享著req和res，所以前者所做的變動，後者會看到，接著等到funct1的next()所呼叫的函式將控制權返回至funct1時，便會執行do something 2，

```
function funct1(req, res, next) {
  // do something 1

  next()
  // do something 2
}
```

2. 實現結束cycle的方式主要方式為在同一個Middleware上的Middleware function進行回應請求，就即可結束cycle，但實際上還是仍依照著next()是否還在而繼續執行下一個function，根據next()是否停在做出回應的function而可以分為兩種形式：

 - 當前面的function已經做出回應但該function仍繼續執行著next()：當一個請求X被伺服器接收並轉換成request這個物件，由於同一種middleware的function會共享於request和response這兩個物件，所以只要任意一個function對request進行回應封包的發送，就能順利地結束請求X的cycle，但由於負責做出回應的function以及之後的function也做出了next()，而這情況會一直執行到第n個function才正式停止執行。
```
// 前面的函式已經對請求X來回應，但該函式仍繼續執行next()
function functM(req, res, next) {
  .
  .
  res.send(something)/res.rend(something)
  .
  .
  next()
}
.
.
.

function functN(otherParameter) {
  // do something1
}
```

 - 做出回應的function不在執行next
 ```
function functM(req, res) {
  .
  .
  res.send(something)/res.rend(something)
  .
  .
}
 ```


3. 同一種Middleware的Middleware function執行順序會依照程式碼讀取的先後順序而決定，主要有 以參數來決定 和 同一種middleware的程式碼擺放來決定，


4. 以參數來決定： 在這裏先提以參數來決定，在這裡假定除了最後一個Middleware function不會呼叫next()以外，其餘的function會呼叫next()，最先讀取到的function先被執行，然後再由它呼叫next()執行第二個function，每一種可允許放多個Middleware function的Middleware都會有1-N個參數位置可填入多個Middleware function，該參數可填入以下形式：
 - 一個Middleware function：由這個來構成最後一個function來結束cycle或者執行next()
 - 由一個陣列來存放多個Middleware function：會按照陣列的索引值(index)的先後順序來執行，索引值為0的函式會最先執行，接著他在執行next()去呼叫索引值為1的函式，然後再由索引值為1的函式去透過next()呼叫索引值為2的函式，後面以此類推。
 - 以多個參數來表示多個Middleware function，如(funct1, funct2,... functN)：會按照參數位置的先後順序來執行，放在第一個參數會的函式先被執行，然後由這個函式來透過next()呼叫第二個參數的函式，第二個參數的函式再透過next()呼叫第三個參數的函式，後面以此類推。
 - 上列的組合：由於參數位置可以填入N個，因此可以將上面的形式組合再一起來填入

5. 舉例：首先先建立三個物件first、second、third來指向三個函式物件，first指向的函式會在終端機介面印出'first'以及執行next()，而second則是印出second、呼叫response的send方法來傳遞訊息、執行next()，最後一個third則是單純印出'third'，接著將這三個函式物件以陣列array來存放，並放置app.use這個middleware當middleware function的參數，

```
const first = (req, res, next) => {
  console.log('first')
  next()
}
const second = (req, res, next) => {
  console.log('second')
  res.send('test msg')
  next()
}

const third = (req, res) => {
  console.log('third')
}
const array = [first, second, third]

app.use(array)
```

在這裏app.use會根據陣列的索引值來挑選first來當第一個執行的middleware function，接著first執行完之後就由first來透過next()呼叫索引值為1的函式-second，second會印出以及利用res.send的特性先做出回應請求(回傳回應封包)的動作，接著就是由second透過next()呼叫third這middleware function，由他來將response 物件回傳給客戶端使用。但若second內是用res.render來代替send的話，render要渲染的資料會存放response 物件而不能夠先做出回應請求，只能等最後最後一個middleware回傳給客戶端，才能讓客戶端正常渲染


![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636198617/blog/middleware/middlewareExample_iwyyz5.png)

## res.send vs. res.render
1. 若將兩者設定在某一個middleware function中，且該function並不是最後一個function，由於每個function都共享著request物件和response物件且會由最後一個function來傳遞response物件給客戶端，而該物件會代表著伺服器要回應的東西。
2. 考量上述的背景，res.send就設定了一場實驗來驗證是否會被最後一個function所影響，最後一個function會延遲10秒才發送給客戶端，結果是res.send會在執行最後一個function前就提前發送回應給客戶端，而不等最後一個function執行完才正式發送

```
function syncDelay(milliseconds) {
  var start = new Date().getTime();
  var end = 0;
  while ((end - start) < milliseconds) {
    end = new Date().getTime();
  }
}


const first = (req, res, next) => {
  console.log('hi')
  next()
}
const second = (req, res, next) => {
  console.log('second')
  res.send('test msghhwedwdew')
  next()
}
const third = (req, res) => {
  console.log('third')
  console.log("Before the delay")
  syncDelay(10000);
  console.log("After the delay")
}
const array = [first, second, third]

app.use(array)

```

3. 考量到上述背景，res.render也跟著設定擺在同種實驗，最後一個function會延遲十秒才回應給客戶端，結果render的效果真要等最後一個function發送客戶端才會正常顯示。

```
function syncDelay(milliseconds) {
  var start = new Date().getTime();
  var end = 0;
  while ((end - start) < milliseconds) {
    end = new Date().getTime();
  }
}


// static file directory
app.use('/', express.static('public'))

// define route
app.get('/', (req, res, next) => {
  res.render('index')
  next()
})

app.use('/', (req, res) => {
  console.log('hians')
  console.log("Before the delay")
  syncDelay(10000);
  console.log("After the delay")

})

```

4. 總結一下，res.send會不管後續的function為何都會直接發送回應給客戶端，而res.render則是因為它渲染的內容全存在response這物件，必須由最後一個function來發送response物件給客戶端才能正常讓客戶端拿到渲染內容。