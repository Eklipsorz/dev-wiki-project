---
sidebar_position: 14
---


# U54 技術和新知



## body parser
1. 由於post是將資料存放於封包上的message body上，而不是像get那麼直接就把資料放在URL，而express在4.17.1以前並沒有一個好方法能夠方便取得post傳遞過來的資料，因此會使用者body parser這套件來方便擷取，隨後4.17.1之後就內建了該套件來讓express能夠方便擷取post的資料。



## Middleware in express.js
1. 該Middleware在node.js/express.js中會是夾雜在request/response cycle之間的程式碼模組，也就是下圖中的Middleware，request 則是客戶端發送的請求，而response則是客戶端請求所要的回應或者功能，request/response cycle則是發送特定請求n和回應特定請求n之間的處理過程，當客戶端發送請求n至伺服器時，便開始該請求的cycle，而當伺服器回應該請求後，就便結束了該請求的cycle。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636120588/blog/middleware/req_res_middleware_ml8hxi.png)
2. Middleware 由於夾雜在 request 和 response 之間，所以可以存取分別代表request和response的物件。
3. 根據用途，express.js 的 Middleware 根據用途分為：
 - 應用程式種類： app.use
 - 路由種類：router.use
 - 內建通用：express.static, express.json, express.urlencoded
 - 錯誤處理種類：app.use(err, req, res, next)
 - 第三方種類(由第三方所提供的Middleware)：bodyparser, cookieparser

## app.use
1. 應用程式種類的Middleware，當目前請求的URL是和app.use所需的URL呈現一致的時候，會執行特定的middleware function
2. app.use 語法形式會是： path 是要匹配且為相對路徑的URL，而 callback 則是呈現一致時所要執行的middleware function
```
app.use(path, callback)
```






### 參考資料
1. [How Node JS middleware Works?](https://selvaganesh93.medium.com/how-node-js-middleware-works-d8e02a936113)

## Middleware function
1. Middleware 代表兩個對象之間的程式碼模組，function則是函式，組合再一起就是夾雜兩個對象之間的函式
2. Middleware 對於請求的回應，通常會是由多個 Middleware function 所組成並協同完成請求，每個Middleware function都因為同為Middleware而能共享於代表request和response的物件。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636123665/blog/middleware/multipleMiddlewareFunction_eyk4ub.png)

3. 每個Middleware function都能執行next()來調用下一個Middleware function 或者 結束cycle 並當成回應來回傳客戶端的請求，通常每個 Middleware Function 都會把自己的輸出處理結果當作是下一個 Middleware function 的輸入參數來處理，最後再由宣布結束cycle的函式來回傳最後的結果

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636124064/blog/middleware/twoCasesMiddlewareFunctions_okwbxj.png)

4. 整體來說，每個Middleware function會呈現一個會維持queue的狀態來等待上一個function將控制權轉交。

5. 如果目前的Middleware function沒執行next()或者沒結束cycle的話，有可能會讓客戶端保持著等請求回應的狀態

## 實際使用Middleware Function
1. 實現能執行next()來調用下一個Middleware function的Middleware function會是以下形式，req和res分別為代表請求request和請求回應response這兩個物件，而next是指向函式物件的參數，而當你在funct1中的某一段放入next()的話，系統執行到那段便會由funct1呼叫另一個Middleware function，而該Middleware function由於共享著req和res，所以前者所做的變動，後者會看到，接著等到funct1的next()所呼叫的函式將控制權返回至funct1時，便會執行do something 2，

```
function funct1(req, res, next) {
  // do something 1

  next()
  // do something 2
}
```

2. 實現結束cycle的方式主要方式為在同一個Middleware上的Middleware function進行回應請求，就即可結束cycle，但實際上還是仍依照著next()是否還在而繼續執行下一個function，在這裡主要有兩種形式：

- 當前面的function已經做出回應但該function仍繼續執行著next()：當一個請求X被伺服器接收並轉換成request這個物件，由於同一種middleware的function會共享於request和response這兩個物件，所以只要任意一個function對request進行回應封包的發送，就能順利地結束請求X的cycle，但由於負責做出回應的function以及之後的function也做出了next()，而這情況會一直執行到第n個function才正式停止執行。
```
// 前面的函式已經對請求X來回應，但該函式仍繼續執行next()
function functM(req, res, next) {
  .
  .
  res.send(something)/res.rend(something)
  .
  .
  next()
}
.
.
.

function functN(otherParameter) {
  // do something1
}
```



實現 Middleware function 的主要方法就是將特定函式物件放入每個可允許分割成多個 Middleware function 的Middleware，而 Middleware 允許放入 Middleware function 的方式有四種：

2. 將一個函式物件放入Middleware，而Middleware會是如下形式，callback是一個函式物件
```
Middleware(otherArguments, callback)
```
而函式物件不管是否為擁有next參數的函式皆能放，

```
  // 擁有next參數的函式
  function funct1(req, res, next) {
    // do something
    next()
  }

  // 沒擁有next參數的函式
  function funct1(req, res) {
    // do something
  }
```

