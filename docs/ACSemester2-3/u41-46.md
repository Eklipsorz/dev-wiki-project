---
sidebar_position: 11
---

# U41-46 技術和新知


## view 詳細分工
1. view 在 MVC 架構中負責呈現使用者介面的呈現以及透過介面來收集資料
2. 由於view本身會藉由controller來獲取model所得到的動態資料來和自己內部所存下的模板網頁(template)一起合併，至於如何合併就有兩個小課題：
 - template：定義靜態網頁和靜態網頁佈局
 - logic：定義如何將動態資料與template合併時所需要處理的判斷或者邏輯/顯示內容時需要處理的判斷或程式邏輯

## Escape
1. 原意為從某種東西跳脫，在電腦科學裡會是 跳脫原本被(顯示的)定義的形式並轉換(轉義)為另一個形式。
2. 舉例：若形容某字串是HTML-ESCAPING，就代表這字串跳脫字串原本的形式而轉換至HTML的形式。

## Handlerbars Helper
1. Handlebars 語言中的函式，如同一般程式語言的函式那般，可以定義函式的功能以及如何呼叫，handlebars有內建的Helper可以使用，所以不必每個Helper都需要定義才能使用。
2. 而定義/宣告Handlebars Helper只能夠在JavaScript來定義，形式會是：helperName為Helper的名字，而後面的函式內容是定義Helper的功能，裡頭的parameter正式helper所需要的參數，最後會回傳特定值，而這個值將會回傳到helper在template file的所在位置，換言之，會是由回傳值來代替helper
```
Handlebars.registerHelper(helperName, function (parameter) {
    /* do something */
    return something
})
```
3. 使用Helper所宣告/定義的形式會是以下面形式出現在template file，並且會間接呼叫對應的JavaScript函式之轉換成機器可辨識執行的形式。

```
{{helperName parameter}}
```
4. 舉例：定義一個名為loud的Helper，這個Helper會對應參數名稱為aString的函式物件，接著只要在template file裡使用loud這helper名稱就能接間呼叫擁有參數名為aString的函式物件，並由它來回傳aString大寫轉換結果，其結果會替代在{{loud lastname}}所在位置。

```
/* Inside JavaScript file */
Handlebars.registerHelper('loud', function (aString) {
    return aString.toUpperCase()
})

/* Inside template file */
{{loud lastname}}
```

## Handlebars block helper
1. 另一種形式的helper，會利用類似標籤的形式構建出一個區塊(block)來允許開發者在內部填寫內容context讓helper把內容當作另一種參數來處理，換言之，helper會使用 parameter 和 context 來處理helper本身定義的功能，而這種形式的helper得名為block helper，另外block helper也存在著handlebars內建的block helper，如each。


```
{{#helperName parameter}}

context

{{/helperName}}

```

2. 舉例：each為內建的block helper，會根據參數numbers的長度length來迭代/執行length次，參數通常是可迭代/可遍歷的物件，比如陣列，而this會對應每次迭代時會回傳的內容，比如陣列指定位置下的元素。

```
{{#each numbers}}
  {{this}}
{{/each}}
```


## Handlebars Expression
1. 皆用{{ A }}來告訴系統請以Handlebars 語言來解析內容A。
2. 若A為變數名稱的話，會直接從變數內容取值，其值會是一般文字(string)，比如{{ variable }} 就是讓handlebars從variable變數取值並放入variable所在的位置。
```
{{ A }}
```
3. 若A為{A}，會要求系統進行HTML-Escaping/告知系統內容A已經跳脫原本顯示的形式，請以HTML語言來定義其內容，別以一般字串來看待。

```
{{{A}}}
```

4. 若A為helpername parameter…. ，會以handlerbars的hepler來將helpername當作helper的名稱，並把後面的參數parameter來當作helper的參數來處理，而參數部分可由變數來決定，最後的結果會根據helper對應的函式結果來決定。
```
{{helpername parameter}}
```

5.  若{{ A }} 會是如下，會是另一種helper，只是參數不只是用parameter，還會用{{#helperName}}和{{/helperName}}之間的內容context，而helperName則是helper 名稱，這種形式的helper稱之為block helper，同樣地，block helper也擁有著內建helper的。

```
{{#helperName parameter}}

context

{{/helperName}}

```

## 模組
1. JavaScript 正式規範(ECMAScript)中並沒有明確定義模組化的機制，但在私底下的開發社群中有定義一個名為CommonJS的模組化標準，而Node.js本身有遵從並實現其標準，因此在一般非Node.js環境並不能夠使用模組化相關的語法，而Node.js的執行環境上支援模組化相關的語法。
2. 模組本身是一個特殊物件，可以將JavaScript任意型別的資料(含函式物件)轉換成模組物件來處理。
3. 模組化的require語法會是

```
require(fileName)
```



### 參考資料
1. [[第三週] Node.js 基礎 — module.exports 和 require](https://miahsuwork.medium.com/第三週-node-js-基礎-module-exports-和-require-2f9f6915d9f0)
2. [Day5 - 關於 module.exports 的兩三事](https://ithelp.ithome.com.tw/articles/10185083)

## 需要跟模板網頁做結合的資料可以存放在
1. 資料庫
2. 伺服器主機
3. 第三方主機
4. App.js (通常不會放在這，不易維護)
