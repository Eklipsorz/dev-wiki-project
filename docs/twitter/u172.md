---
sidebar_position: 6
---

# 調整專案架構：路由器分流

## pages 路徑 vs. apis 路徑
1. pages(含控制器內的pages、路由系統內的pages)是以複數形式來表示**專門存放多個頁面渲染相關的模組**或者**存放多個專門回傳頁面至客戶端的程式模組**
```
// 專案下的controllers下之pages路徑，其目錄專門存放頁面渲染相關的控制器
/project/controllers/pages/*

// 專案下的routes下之pages路徑，其目錄專門定義每個路由上對應的頁面是什麼
/project/routes/pages/*
```
2. apis(含控制器內的apis、路由系統內的apis)是以複數形式來表示**專存放多個API相關的模組**或者**存放多個專門回傳API回傳物件(通常會是JSON)至客戶端的程式模組**

```
// 專案下的controllers下之apis路徑，其目錄專門存放API相關的控制器
/project/controllers/apis/*

// 專案下的routes下之apis路徑，其目錄專門定義每個路由上對應的API是什麼
/project/routes/pages/*
```
3. 若要同時讓伺服器同時提供pages和apis對應的程式模組至客戶端的話，其主路由會是route/index.js，並分成專門回傳畫面至客戶端的pages目錄以及專門回傳JSON物件至客戶端的apis目錄，這兩個目錄下會各自有index.js來定義畫面上的路徑和api的路徑
```
const { apis, pages } = require('./routes/') 

// 為了避免下面路由攔截到/api相關請求，而將綁定api的路由往上放。
app.use('/api', apis) 
app.use(pages)


// 主路由 - /routes/index.js內容 
const pages = require('./pages')
const apis = require('./apis')

exports = module.exports = {
  pages,
  apis
}
```


routes/apis/index.js內容如下：
  - 定義認證機制middleware來防止外人使用
  - 定義主要提供的API，在這裡會是GET /api/restaurants綁定於restController的屬性-getRestaurants
```
const express = require('express')
const router = express.Router()

const { authenticated } = require('../../middleware/auth')
const restController = require('../../controllers/apis/restaurant-controller')

router.get('/restaurants', authenticated, restController.getRestaurants)

exports = module.exports = router
```
而routes/pages/index.js內容主要會是將負責渲染畫面的路由系統擺放至這
```
const express = require('express')
const router = express.Router()
...
module.exports = router
```

## API對應Controller實作：GET /api/restaurants
1. GET /api/restaurants是以回傳一個具有所有餐廳資訊以及分頁器資訊的物件為主的API路徑，主要會以res.json來以JSON物件來回傳至客戶端

2. 主要會實作在controllers/apis/restaurant-controller.js
```
const { Restaurant, Category } = require('../../models')
const { getOffset, getPagination } = require('../../helpers/pagination-helper')
const restaurantController = {
  getRestaurants: (req, res) => {
    const DEFAULT_LIMIT = 9
    const categoryId = Number(req.query.categoryId) || ''
    const page = Number(req.query.page) || 1
    const limit = Number(req.query.limit) || DEFAULT_LIMIT
    const offset = getOffset(limit, page)
    Promise.all([
      Restaurant.findAndCountAll({
        include: Category,
        where: {
          ...categoryId ? { categoryId } : {}
        },
        limit,
        offset,
        nest: true,
        raw: true
      }),
      Category.findAll({ raw: true })
    ])
      .then(([restaurants, categories]) => {
        const favoritedRestaurantsId = req.user.FavoritedRestaurants.map(fr => fr.id)
        const likedRestaurantsId = req.user.LikedRestaurants.map(lr => lr.id)
        const data = restaurants.rows.map(r => ({
          ...r,
          description: r.description.substring(0, 50),
          isFavorited: favoritedRestaurantsId.includes(r.id),
          isLiked: likedRestaurantsId.includes(r.id)
        }))
        return res.json({
          restaurants: data,
          categories,
          categoryId,
          pagination: getPagination(limit, page, restaurants.count)
        })
      })
  }
}
module.exports = restaurantController
```


## 補充知識：res.json(object)
1. 指定回傳客戶端的內容形式和主內容會分別是以json物件形式以及object所指定的屬性內容
> Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a JSON string using JSON.stringify().
2. 語法形式為如下，但語法上只是告知express在處理完middleware的後續行為就以目前res內容來回傳至客戶端
```
res.json(object)
```
  - 若在同一層middleware要指示回傳json物件但又不是以return來告知停止後續的處理，會直接執行後面的計算-等待4秒，在這4秒內並不會讓客戶端收到json物件，而是等完4秒後才會回傳json物件
  ```
  {
    ..
    .
    .
    res.json({
          restaurants,
          categories,
          categoryId,
          pagination: paginatorHelpers.getPagination(limit, currentPage, count)
    })
    const d = new Date()
    let d2 = null
    do { d2 = new Date() }
    while (d2 - d < 4000)
  }
  ```
  - 延續第一點，若後者還有middleware要執行的話，會先以處理完所有相關的middleware才會回傳最後的res所包含的結果。