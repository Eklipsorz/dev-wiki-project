---
sidebar_position: 14
---

# 實作身份認證的 middleware

實作會有兩個階段：

設定 Passport-jwt 策略
實作 middleware 並加入路由


![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1645117258/twitter/course/passportJWT_kb02zr.png)

fromAuthHeaderAsBearerToken 建立一個提取器，專門會以bearer token為主尋找對應的token

fromAuthHeaderAsBearerToken() creates a new extractor that looks for the JWT in the authorization header with the scheme 'bearer'

當使用者獲得token並向同一個伺服器使用token去索要該平台需要認證的服務時，使用者會發送一個封包，該封包上的Authorization Header會是Bearer字串 和 token 所合併的字串，而這樣子合併的字串又被稱之為bearer token
> Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema. The content of the header should look like the following:

```
Authorization: Bearer <token>
```
bearer token 實現方法會是依據OAuth2.0規範來實現的

jwtFromRequest：用來指定提取器，該提取器是負責從請求中找出哪一段字串是JWT的主體，
> Extracting the JWT from the request: There are a number of ways the JWT may be included in a request. In order to remain as flexible as possible the JWT is parsed from the request by a user-supplied callback passed in as the jwtFromRequest parameter. This callback, from now on referred to as an extractor, accepts a request object as an argument and returns the encoded JWT string or null.
[使用JWT來存取API內容(總結) && bearer](https://ithelp.ithome.com.tw/articles/10197166)


The server's protected routes will check for a valid JWT in the Authorization header, and if it's present, the user will be allowed to access protected resources. If the JWT contains the necessary data, the need to query the database for certain operations may be reduced, though this may not always be the case.

```
const passport = require('passport')
const LocalStrategy = require('passport-local')
const passportJWT = require('passport-jwt') //新增這行，引入 passport-jwt
const bcrypt = require('bcryptjs')
const { User, Restaurant } = require('../models')
// 載入JWT策略物件
const JWTStrategy = passportJWT.Strategy
// 載入從封包中提取JWT內容的提取器模組
const ExtractJWT = passportJWT.ExtractJwt

const jwtOptions = {
  // 設定如何提取JWT
  jwtFromRequest: ExtractJWT.fromAuthHeaderAsBearerToken(),
  // 用secretOrKey來將目前擷取到JWT內的header和payload組成一個亂碼來比對目前事先拿到的亂碼
  secretOrKey: process.env.JWT_SECRET
}
passport.use(new JWTStrategy(jwtOptions, (jwtPayload, cb) => {
  // 在這裡預設為亂碼一致或驗證成功，在這裡的jwtPayload 會是已經用BASE64反解開的資訊-物件
  // cb代表passport.js的done function
  // 在這裡會拿到對應使用者的id，並找到對應使用者、使用者相關聯的表格紀錄
  User.findByPk(jwtPayload.id, {
    include: [
      { model: Restaurant, as: 'FavoritedRestaurants' },
      { model: Restaurant, as: 'LikedRestaurants' },
      { model: User, as: 'Followers' },
      { model: User, as: 'Followings' }
    ]
  })
    .then(user => cb(null, user))
    .catch(err => cb(err))
}))

```
config/passport.js出現以下訊息
```
TypeError: JwtStrategy requires a secret or key
```

原因出自於passport.js無法正常辨識環境變數，需要額外載入donenv
[('JwtStrategy requires a secret or key');](https://stackoverflow.com/questions/45525077/nodejs-typeerrorjwtstrategy-requires-a-secret-or-key/50787319)

在config/passport.js添加來解決
```
if (process.env.NODE_ENV !== 'production') {
  require('dotenv').config()
}
```


在 Passport 的設定檔做好認證程序之後，我們要把認證程序用 middleware 的方式加入路由。

請新增一個 API 專用的檔案：

touch middleware/api-auth.js



403 Forbidden 客戶端錯誤狀態碼表示伺服器理解該請求但拒絕核准
 - 存取被永久性禁止，且與應用程式邏輯有關，如資源的訪問權限不足。