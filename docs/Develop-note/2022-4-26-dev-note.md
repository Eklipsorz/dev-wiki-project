---
sidebar_position: 5
---

# 2022-4-26-開發日記

## 將多餘的設定檔案統一成一檔案
原本是想將每個模組所需要的全域變數依模組種類和模組名稱來區分成多個檔案，但實際上來說會造成幾個小問題：
  - 開發、維護性會因為區分太多而變難
  - 部分模組還未有全域變數的需要，造成空白檔案
  - 部分全域變數可以轉換成整個專案所需，比如黑名單本身就設定在account service，但實際上來說還有其他程式模組會需要同樣內容黑名單。

因此將所有模組的全域變數統一至/config/project.js，並把相關的程式模組轉換為generalConfig、controller、service、middleware、seeder物件，裡頭進一步存放實際上的程式模組名稱，比如說controller裡會有user-controller，所以controller物件會有userController屬性來存放該檔案所需的全域變數，如下所示
```
const controller = {
  userController: {
    ....
  }
}

```

整體來說，最後再將這些物件作為模組主要輸出的內容，另外通用配置generalConfig會存放著類似於黑名單清單的資料來給予多個程式模組來使用
```
const generalConfig = {
  ...
}

/* controller config */
// const controller = {
//   userController: {

//   },
//   adminController: {

//   }
// }

/* service config */
// const service = {
//   accountService: {

//   },
//   userService: {

//   },
//   adminService: {

//   }
// }

/* middleware config */
const middleware = {
  APIErrorHandler: {
    ....
  }
}

/* seeder config */
const seeder = {
  usersSeeder: {
    ....
  }
}

exports = module.exports = {
  // controller,
  // service
  generalConfig,
  middleware,
  seeder
}
```




## passport.use 方式和策略定義

passport.use 是定義passport要使用的驗證策略是為何，而參數就是實際代表驗證策略的物件，在這裡會是以/config/passport.js作為範例，範例中會使用者JWT 驗證策略，其策略的建構式參數為物件Options、函式物件JWTVerify，前者是定義著該驗證策略如何解開JWT(包含使用哪一種密鑰和哪一種算法解開)，後者則是定義使用密鑰解開後JWT後該如何做後續的驗證JWTVerify，換言之，當驗證策略解開JWT後就呼叫JWTVerify

```
new JWTStrategy(Options, JWTVerify)
```

JWTVerify本身包含兩者參數：payload、cb，前者為JWT解開後的內容，其內容會是JWT內含的payload部分，而cb則是依據參數的給定來通知passport其驗證結果是失敗或者成功。
```
JWTVerify(payload, cb)
```

```
const JWTStrategyOptions = {
  jwtFromRequest: ExtractJWT.fromAuthHeaderAsBearerToken(),
  secretOrKey: process.env.ACCESS_TOKEN_SECRET
}

async function JWTVerify(payload, cb) {
  try {
    const user = await User.findByPk(payload.id)

    if (!user) return cb(null, false)
    return cb(null, user.toJSON())
  } catch (error) {
    return cb(error, false)
  }
}

passport.use(new JWTStrategy(JWTStrategyOptions, JWTVerify))

exports = module.exports = passport

```

參考資料：
[Authenticate request based on JWT obtained from header or post body](https://github.com/mikenicholson/passport-jwt/blob/master/lib/strategy.js)
[passport 套件本身](https://github.com/jaredhanson/passport/blob/master/lib/middleware/authenticate.js)
[How failure message works in Passport.js](https://medium.com/tds-note/how-failure-message-works-in-passport-js-512e453af8a3)


```
/**
 * Strategy constructor
 *
 * @param options
 *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.
 *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,
 *                               which should call done with a secret or PEM-encoded public key
 *                               (asymmetric) for the given undecoded jwt token string and  request
 *                               combination. done has the signature function done(err, secret).
 *                               REQUIRED unless `secretOrKey` is provided.
 *          jwtFromRequest: (REQUIRED) Function that accepts a request as the only parameter and returns the either JWT as a string or null
 *          issuer: If defined issuer will be verified against this value
 *          audience: If defined audience will be verified against this value
 *          algorithms: List of strings with the names of the allowed algorithms. For instance, ["HS256", "HS384"].
 *          ignoreExpiration: if true do not validate the expiration of the token.
 *          passReqToCallback: If true the verify callback will be called with args (request, jwt_payload, done_callback).
 * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,
 *                 (request, jwt_payload, done_callback) if true.
 */
```






## 根據驗證策略而生出的驗證middleware
根據載入的passport物件來呼叫authenticate生出對應驗證策略的middleware，其middleware會是實際上從請求封包獲取JWT並做驗證、賦予驗證結果至req.user。
```
const passport = require('../config/passport')
const authenticated = (req, res, next) => {
  passport.authenticate('jwt', { session: false }, (err, user) => {
    const error = new Error()

    if (err || !user) {
      error.code = 401
      error.message = '使用者未從登入驗證獲取憑證不予使用'
      return next(error)
    }

    req.user = user
    return next()
  })(req, res, next)
}
```
其中passport.authenticate參數會是如下，name是告知passport要使用哪一種驗證策略實作，options是設定驗證過程所需的參數，cb實際上是決定驗證結果事後要做些什麼？預設會是指定 **成功驗證就嘗試賦予使用者資料至req.user，或者設定失敗驗證嘗試賦予什麼至req.user**
```
passport.authenticate(name, options, cb)
```

該cb會接在實際驗證策略下的JWTVerify中的done之後，該done會通知其驗證結果至passport，然後在呼叫authenticate所回傳的middleware之cb
```
new JWTStrategy(JWTStrategyOptions, JWTVerify)
JWTVerify(payload, done)
```



Note: 
1. Middleware = passport.authenticate()..
2. Middleware 策略內容為passport.use所使用的定義
3. if (err || !user)  中的 !user是因為jwt策略有將驗證失敗的結果-user設為false(由策略下的verify所帶的done_cb)
> An optional `callback` can be supplied to allow the application to override
>  * the default manner in which authentication attempts are handled.The
>  * callback has the following signature, where `user` will be set to the
>  * authenticated user on a successful authentication attempt, or `false`
>  * otherwise.An optional `info` argument will be passed,


> In this route, passport.authenticate() is middleware which will authenticate the request. By default, when authentication succeeds, the req.user property is set to the authenticated user, a session is established, and the next function in the stack is called. This next function is typically application-specific logic which will process the request on behalf of the user.
> When authentication fails, an HTTP 401 Unauthorized response will be sent and the request-response cycle will end. Any additional functions in the stack will not be called. This default behavior is suitable for APIs obeying representational state transfer (REST) constaints, and can be modified using options.


## 刪除多餘的屬性

刪除密碼屬性
const resultUser = getUser(req)
      delete resultUser.password

## sequelize hook 功能

Hook => event binding
Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a beforeUpdate hook.
Note: You can't use hooks with instances. Hooks are used with models.


## 從服務中切分出無關認證的路由

```
// 前台登入
router.post('/users/login', userController.login)

// 前台註冊
router.post('/users', userController.register)

// 後台登入
router.post('/admin/login', adminController.login)

router.use('/users', authenticate, authenticateUser, userRoutes)
router.use('/admin', authenticate, authenticateAdmin, adminRoutes)

router.use(APIErrorHandler)
exports = module.exports = router
```


## 認證、認證使用者、認證管理員的middleware
```
function authenticate(req, res, next) {
  function cb(error, user) {
    if (error || !user) {
      return next(new APIError({ code: code.FORBIDDEN, message: '使用者未從登入驗證獲取憑證不予使用' }))
    }
    req.user = user
    return next()
  }

  const verify = passport.authenticate('jwt', { session: false }, cb)
  verify(req, res, next)
}

function authenticateUser(req, _, next) {
  const user = getUser(req)
  if (!user || blackListRoleIn.user.includes(user.role)) {
    return next(new APIError({ code: code.NOTFOUND, message: '帳號不存在' }))
  }
  return next()
}

function authenticateAdmin(req, _, next) {
  const user = getUser(req)
  if (!user || blackListRoleIn.admin.includes(user.role)) {
    return next(new APIError({ code: code.NOTFOUND, message: '帳號不存在' }))
  }
  return next()
}


```

## 實作getUser

/helpers/auth-helper.js
```

function getUser(req) {
  return req.user || null
}

function getUserId(req) {
  return getUser(req)?.id
}

exports = module.exports = {
  getUser,
  getUserId
}

```
## 實作註冊表單和更新設定表單檢查

formdata-check-helper.js

registerFormValidator:
```
  // 電子郵件重複註冊
  if ((await User.findOne({ where: { email } }))) {
    messageQueue.push('電子郵件重複註冊')
  }

  // 帳號重複註冊
  if ((await User.findOne({ where: { account } }))) {
    messageQueue.push('帳號重複註冊')
  }

  // 暱稱重複註冊
  if ((await User.findOne({ where: { nickname } }))) {
    messageQueue.push('暱稱重複註冊')
  }
```

updateFormValidator:
```
  // 電子郵件重複註冊
  if (resultByEmail && currentUserId !== resultByEmail.id) {
    messageQueue.push('電子郵件重複註冊')
  }

  // 帳號重複註冊
  if (resultByAccount && currentUserId !== resultByAccount.id) {
    messageQueue.push('帳號重複註冊')
  }

  // 暱稱重複註冊
  if (resultByNickname && currentUserId !== resultByNickname.id) {
    messageQueue.push('暱稱重複註冊')
  }

```
