---
sidebar_position: 5
---

# 2022-4-26-開發日記

## 將多餘的設定檔案統一成一檔案
原本是想將每個模組所需要的全域變數依模組種類和模組名稱來區分成多個檔案，但實際上來說會造成幾個小問題：
  - 開發、維護性會因為區分太多而變難
  - 部分模組還未有全域變數的需要，造成空白檔案
  - 部分全域變數可以轉換成整個專案所需，比如黑名單本身就設定在account service，但實際上來說還有其他程式模組會需要同樣內容黑名單。

因此將所有模組的全域變數統一至/config/project.js，並把相關的程式模組轉換為generalConfig、controller、service、middleware、seeder物件，裡頭進一步存放實際上的程式模組名稱，比如說controller裡會有user-controller，所以controller物件會有userController屬性來存放該檔案所需的全域變數，如下所示
```
const controller = {
  userController: {
    ....
  }
}

```

整體來說，最後再將這些物件作為模組主要輸出的內容，另外通用配置generalConfig會存放著類似於黑名單清單的資料來給予多個程式模組來使用
```
const generalConfig = {
  ...
}

/* controller config */
// const controller = {
//   userController: {

//   },
//   adminController: {

//   }
// }

/* service config */
// const service = {
//   accountService: {

//   },
//   userService: {

//   },
//   adminService: {

//   }
// }

/* middleware config */
const middleware = {
  APIErrorHandler: {
    ....
  }
}

/* seeder config */
const seeder = {
  usersSeeder: {
    ....
  }
}

exports = module.exports = {
  // controller,
  // service
  generalConfig,
  middleware,
  seeder
}
```




## passport.use 方式和策略定義



/config/passport.js

passport.use(new JWTStrategy(jwtOptions, (jwtPayload, cb) => {
  return User.findByPk(jwtPayload.id, {
    include: [
      { model: User, as: 'Followers' },
      { model: User, as: 'Followings' }
    ]
  })
    .then(user => {
      if (!user) cb(null, false)
      return cb(null, user.toJSON())
    })
    .catch(err => cb(err))
}))

Verify => 主要負責驗證請求封包內的資訊是否正確，執行時機是收到請求封包並解開其jwt
Verify(req, done_cb) => done_cb主要是給予開發者來通知passport目前驗證結果


done_cb 則是 根據done_cb實際參數值來決定策略下的success、fail函式，這些函式會間接通知passport



Authenticate request based on JWT obtained from header or post body

https://github.com/mikenicholson/passport-jwt/blob/master/lib/strategy.js

passport 套件本身
https://github.com/jaredhanson/passport/blob/master/lib/middleware/authenticate.js

https://medium.com/tds-note/how-failure-message-works-in-passport-js-512e453af8a3

```
/**
 * Strategy constructor
 *
 * @param options
 *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.
 *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,
 *                               which should call done with a secret or PEM-encoded public key
 *                               (asymmetric) for the given undecoded jwt token string and  request
 *                               combination. done has the signature function done(err, secret).
 *                               REQUIRED unless `secretOrKey` is provided.
 *          jwtFromRequest: (REQUIRED) Function that accepts a request as the only parameter and returns the either JWT as a string or null
 *          issuer: If defined issuer will be verified against this value
 *          audience: If defined audience will be verified against this value
 *          algorithms: List of strings with the names of the allowed algorithms. For instance, ["HS256", "HS384"].
 *          ignoreExpiration: if true do not validate the expiration of the token.
 *          passReqToCallback: If true the verify callback will be called with args (request, jwt_payload, done_callback).
 * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,
 *                 (request, jwt_payload, done_callback) if true.
 */
```






## 根據驗證策略而生出的驗證middleware

// 驗證目前登入者是否合法，並允許一般前台登入者能進入路由
const authenticated = (req, res, next) => {
  passport.authenticate('jwt', { session: false }, (err, user) => {
    const error = new Error()

    if (err || !user) {
      error.code = 401
      error.message = '使用者未從登入驗證獲取憑證不予使用'
      return next(error)
    }

    req.user = user
    return next()
  })(req, res, next)
}

Middleware = passport.authenticate()..
呼叫順序為：
Middleware (輸出一個負責驗證的middleware，其策略內容為passport.use所使用的定義)
 if (err || !user) { 中的 !user是因為jwt策略有將驗證失敗的結果-user設為false(由策略下的verify所帶的done_cb)

passport.authenticate(name, options, cb)  回傳負責驗證的middleware
name => 決定使用哪一種驗證策略
Options => 設定驗證過程所需的參數
Cb => 決定驗證結果事後要做啥？預設會是在成功驗證嘗試賦予使用者資料至req.user， 或者設定失敗驗證嘗試時賦予什麼至req.user


> An optional `callback` can be supplied to allow the application to override
>  * the default manner in which authentication attempts are handled.The
>  * callback has the following signature, where `user` will be set to the
>  * authenticated user on a successful authentication attempt, or `false`
>  * otherwise.An optional `info` argument will be passed,


> In this route, passport.authenticate() is middleware which will authenticate the request. By default, when authentication succeeds, the req.user property is set to the authenticated user, a session is established, and the next function in the stack is called. This next function is typically application-specific logic which will process the request on behalf of the user.
> When authentication fails, an HTTP 401 Unauthorized response will be sent and the request-response cycle will end. Any additional functions in the stack will not be called. This default behavior is suitable for APIs obeying representational state transfer (REST) constaints, and can be modified using options.


## 刪除多餘的屬性

刪除密碼屬性
const resultUser = getUser(req)
      delete resultUser.password

## sequelize hook 功能

Hook => event binding
Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a beforeUpdate hook.
Note: You can't use hooks with instances. Hooks are used with models.


## 從服務中切分出無關認證的路由

```
// 前台登入
router.post('/users/login', userController.login)

// 前台註冊
router.post('/users', userController.register)

// 後台登入
router.post('/admin/login', adminController.login)

router.use('/users', authenticate, authenticateUser, userRoutes)
router.use('/admin', authenticate, authenticateAdmin, adminRoutes)

router.use(APIErrorHandler)
exports = module.exports = router
```


## 認證、認證使用者、認證管理員的middleware
```
function authenticate(req, res, next) {
  function cb(error, user) {
    if (error || !user) {
      return next(new APIError({ code: code.FORBIDDEN, message: '使用者未從登入驗證獲取憑證不予使用' }))
    }
    req.user = user
    return next()
  }

  const verify = passport.authenticate('jwt', { session: false }, cb)
  verify(req, res, next)
}

function authenticateUser(req, _, next) {
  const user = getUser(req)
  if (!user || blackListRoleIn.user.includes(user.role)) {
    return next(new APIError({ code: code.NOTFOUND, message: '帳號不存在' }))
  }
  return next()
}

function authenticateAdmin(req, _, next) {
  const user = getUser(req)
  if (!user || blackListRoleIn.admin.includes(user.role)) {
    return next(new APIError({ code: code.NOTFOUND, message: '帳號不存在' }))
  }
  return next()
}


```

## 實作getUser

/helpers/auth-helper.js
```

function getUser(req) {
  return req.user || null
}

function getUserId(req) {
  return getUser(req)?.id
}

exports = module.exports = {
  getUser,
  getUserId
}

```
## 實作註冊表單和更新設定表單檢查

formdata-check-helper.js

registerFormValidator:
```
  // 電子郵件重複註冊
  if ((await User.findOne({ where: { email } }))) {
    messageQueue.push('電子郵件重複註冊')
  }

  // 帳號重複註冊
  if ((await User.findOne({ where: { account } }))) {
    messageQueue.push('帳號重複註冊')
  }

  // 暱稱重複註冊
  if ((await User.findOne({ where: { nickname } }))) {
    messageQueue.push('暱稱重複註冊')
  }
```

updateFormValidator:
```
  // 電子郵件重複註冊
  if (resultByEmail && currentUserId !== resultByEmail.id) {
    messageQueue.push('電子郵件重複註冊')
  }

  // 帳號重複註冊
  if (resultByAccount && currentUserId !== resultByAccount.id) {
    messageQueue.push('帳號重複註冊')
  }

  // 暱稱重複註冊
  if (resultByNickname && currentUserId !== resultByNickname.id) {
    messageQueue.push('暱稱重複註冊')
  }

```
