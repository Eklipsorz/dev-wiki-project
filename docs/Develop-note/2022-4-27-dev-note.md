---
sidebar_position: 6
---

# 2022-4-27-開發日記


## content-type -> multipart/form-data
傳統上來說，表單上的資料欄位會全以文字形式或者圖片形式來表現，這使得在傳遞表單上的每筆資料欄位值之資料傳遞形式會全以文字或者圖片形式來傳遞，那時傳遞形式主要有：
  - application/x-www-form-urlencoded：以key-value形式來將資料欄位名稱當作key，而資料欄位值當做value來傳遞，這兩者內容會因為有可能呈現在URL而以percent 編碼的形式來方便讓電腦以及不讓其他電腦上的URL編碼系統將某些字元轉譯，然而percent編碼和以URI來呈現傳遞內容勢必會對 傳遞內容為檔案有些不利，因檔案傳遞上肯定會以0/1來轉換且肯定佔用不少空間。
  - application/json：會以json格式來傳遞
  - text/xml：會以xml格式來傳遞

為了讓前端的表單能夠同時傳遞文字欄位值和圖片/檔案欄位值至伺服器，會設定表單form的enctype屬性為multipart/form-data，讓表單能夠傳遞文字和圖片，圖片/檔案在這會先轉換成0/1來傳遞
  - multipart/form-data：當表格上出現文字和圖片時，會分別以不同的編碼形式來傳遞至目的地
```
// 建立頁面表單
<form action="/admin/restaurants" method="POST" enctype="multipart/form-data"> 
```

```
// 編輯頁面表單
<form action="/admin/restaurants/{{restaurant.id}}?_method=PUT" method="POST" enctype="multipart/form-data"> 
```
[一起理解 HTML 當中的 form-data](https://blog.kalan.dev/2021-03-13-html-form-data/#為什麼需要-form-data？)
note: 
> application/x-www-form-urlencoded: the keys and values are encoded in key-value tuples separated by '&', with a '=' between the key and the value. Non-alphanumeric characters in both keys and values are percent encoded (en-US): this is the reason why this type is not suitable to use with binary data (use multipart/form-data instead)

## 補充：content-type
1. 設定傳輸內容是以何種形式編碼來傳遞：傳統上會是以同一形式來編碼，要嘛內容全都以文字形式來編碼傳遞，要嘛內容全都以檔案形式來編碼傳遞，而為了進行綜合這兩種形式的編碼，而增加了multipart類型。
  - 文字形式：text/html(HTML檔案)、text/plain(純文字)、application/json(JSON檔案)
  - 檔案形式：application/pdf(pdf檔案)、video/mpeg4(影片檔)
  - 綜合文字和檔案形式：multipart/form-data(用於表單資料傳遞)
2. 若表單採用於multipart/form-data的話，當表單發生提交時，可將表單內含的圖片和文字分別以各自形式來編碼並傳遞至伺服器或者目的地，其中enctype是指定發生提交傳遞時以何種形式編碼傳遞。
```
<form enctype="multipart/form-data">
  <input type="file"....>
  <input type="text">
</form>
```

## imgur 1.0.2：定義imgurFileHandler
在這裡使用第三方所開發的套件來間接對imgur進行檔案上傳，但由於開發套件本身只是單純設計到輸出結果或錯誤訊息，本身不會有任何錯誤處理以及從正確結果獲取所需的資料，為了彌補這點，才額外開發imgurFileHandler。


首先，會先設定其imgur的clientId，接著再新增一個名為imgurFileHandler的檔案處理器，其內部會使用imgur.uploadFile來作為promise來使用，若該套件向imgur官方伺服器獲取到狀態碼200的結果，就會直接回傳其上傳後的資料至promise的then，而若套件向imgur官方伺服器獲取到狀態碼非200的結果，就會回傳其失敗結果至promise的catch
```
  const { statusCode: status, statusMessage: message } = response;
  if (status !== 200) {
    throw new Error({
      status,
      message,
    });
  } else {
    return JSON.parse(response.body).data;
  }
```
然而在這裡考慮的是若imgur在狀態碼200的情況下還是會導致導致image為null或者undefined(上傳失敗)，那麼當系統讀取img.link勢必會報錯中斷後續執行，為了能夠在image為null或者undefined的情況下繼續執行，會使用?.運算元來處理，隨後就決定最後的resolve值為null還是image.link。
```
const imgur = require('imgur')
const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID
imgur.setClientId(IMGUR_CLIENT_ID)
.
.
.
const imgurFileHandler = file => {
  return new Promise((resolve, reject) => {
    if (!file) return resolve(null)
    imgur.uploadFile(file.path)
      // 經由原始碼來看的話，只會接收到狀態碼為200的情況
      // 同時在這為了符合測試檔案以及確保狀態碼為200還是會使得img為空值而設值null
      .then(img => resolve(img?.link || null))
      // 經由原始碼來看的話，只會接收到狀態碼不為200的情況
      .catch(error => reject(error))
  })
}

exports = module.exports = {
  localFileHandler,
  imgurFileHandler
}
```


### 補充：imgur.uploadFile(filePath)
1. uploadFile為imgur套件上傳單一檔案的API之一，會是以一個Promise來實現上傳檔案的功能
2. 主要功能就指定一個要上傳的檔案之所在路徑filePath當作檔案上傳至imgur，在過程中，並不會檢查圖片是否已經存在imgur，而是允許上傳並給新的URI來指向它，所以可以重複上傳多個相同的圖片，而每張相同圖片都有各自的URI
3. 形式會是
```
imgur.uploadFile(filePath)
```

## 補充：optional chaining operator
1. chaining operator A.B 是告知系統將A視作為物件，而B會被系統認為是物件A的屬性B或者方法B，接著系統會從物件A尋找是否有名為B的屬性或者方法，若不存在的話，就回傳undefined，可物件A本身不存在或者會是undefined，系統會無法將null或者undefined當正常物件來存取其屬性而報錯並中斷後續執行

2. 報錯並中斷後續執行的案例：
  - case 1是設定obejct1為null，在處理object1.property時，會因為系統無法將null當正常物件來存取property屬性，所以最後系統會立刻中斷並報出錯誤，在這裏other_code1和之後的程式碼會因為中斷關係而沒被執行
  - case 2是設定object2為undefined，在處理object2.property時，會因為系統無法將undefined當正常物件來存取其property屬性，所以最後系統會立刻中斷並報出錯誤，在這裏other_code2和之後的程式碼會因為中斷關係而沒被執行
```
// case 1
object1 = null
do something with object1.property
other_code1

// case 2
object2 = undefined
do something with object2.property
other_code2
```

3. 而為了解決因存取到的物件為null或者undefined而產生出來的屬性報錯中斷問題，官方有提供optional chaining operator A?.B，當物件A是undefined或者null時，會一率回傳undefined，否則就按照A.B來存取物件A的屬性B

4. 以下兩者是相等：若存在擁有屬性B的物件A
1. A && A.B
2. A?.B



## Multer
1. 用途為處理multipart/form-data上的檔案上傳，其檔案上傳的目的地會是本地端的指定目錄下

2. 實際作法為透過該套件產生適合特定檔案上傳的middleware，該middleware只要放在特定路由上，並且在這個路由上進行針對multipart/form-data的指定檔案欄位值的攔截，該middleware就會以檔案的形式來將檔案上傳至本地端的目錄下，等到middleware上傳完檔案就即刻執行這個路由下的後續的middleware

舉例來說：若middleware就為Multer所產生出來的檔案上傳處理之middleware，那麼當輪到它執行時，它會開始進行檔案上傳直到上傳結束才允許系統執行後續的middleware2和middleware3
```
router.use(path, middleware1, middleware, middleware2, middleware3)
```
3. 實際獲取到的功能：
  - 由它產生出來的middleware只要一接收到想要的資料，就會先處理檔案，處理完才執行後續
  - 每一次處理完檔案就會設定處理結果至req，如上傳單個檔案X就會於上傳結束後就將其檔案X資訊寫入至req.file、上傳多個檔案就會於上傳結束後就將這些檔案的資訊寫入至req.files，其內容格式大致上會是
  ```
  file: {
    fieldname: 'avatar', (指定表格上的欄位名稱)
    originalname: '*\x16 2022-04-06 \x0BH7.44.32.png',
    encoding: '7bit', 
    mimetype: 'image/png', 
    destination: 'temp/', (目前檔案所在目錄在哪)
    filename: '9a000efa695f056fb4c9695896d09427', （目前檔案名稱)
    path: 'temp/9a000efa695f056fb4c9695896d09427', (目前上傳檔案儲存在本地端的哪裡)
    size: 99044
  }
  ```
  - 若指定存放上傳檔案的目錄不存在的話，multer會自動建立其目錄來存放

4. 安裝multer
```
npm install multer
```
5. 使用方式：
  - 載入multer套件，其套件本身會以Multer類別的物件來表示
  ```
  const multer = require('multer')
  ```
  
  套件本身會以下面來輸出(以下是multer原始碼)物件
  ```
  function multer(options) {
    if (options === undefined) {
      return new Multer({})
    }

    if (typeof options === 'object' && options !== null) {
      return new Multer(options)
    }

    throw new TypeError('Expected object for argument options')
  }
  ```
  - 替multer設定上傳目的地，在這會是指定當前目錄下的temp/目錄 
  ```
  const multer = require('multer')
  const upload = multer({ dest: 'temp/' })
  ```
  - 根據需求來產生：若要進行單個檔案的上傳就使用multer物件下的single方法來產生對應的middleware，其中參數會是指定從表格資料欄位名稱取出對應值
  ，在這裡會是取得表單上的avatar欄位值，那麼就會是指定avatar做為single參數。
  ``` 
  router.put('/self', upload.single('avatar'), userController.putSelf)
  ```
  single原始碼如下：
  ```
  Multer.prototype.single = function (name) {
    return this._makeMiddleware([{ name: name, maxCount: 1 }], 'VALUE')
  }
  ```
  - 根據需求來產生：若要進行多個檔案的上傳就使用multer物件下的fields方法來產生對應的middleware，其中參數會是指定從表格中的多個指定資料欄位取出對應值，在這裡會是取得表單上的名為avatar的欄位和名為cover的欄位，並從中取出對應的檔案來進行檔案上傳
  ```
  const multiFilesUpload = upload
  .fields([
    { name: 'avatar', maxCount: 1 },
    { name: 'cover', maxCount: 1 }
  ])

  router.put('/:id', multiFilesUpload, userController.putUser)
  ```
## Multer測試：單個檔案上傳時，會是傳哪個屬性
```
 console.log('test file:', req.file, req.files)
```

結果為：
```
test file: {
  fieldname: 'avatar',
  originalname: '*\x16 2022-04-06 \x0BH7.44.32.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'temp/',
  filename: '9a000efa695f056fb4c9695896d09427',
  path: 'temp/9a000efa695f056fb4c9695896d09427',
  size: 99044
} undefined
```
1. 先執行完multiFilesUpload才進入userController.putUser，該multiFilesUpload會先上傳至本地端，putUser路由功能再從本地端上傳至imgur

multiFilesUpload => 
若沒檔案上傳，req.file或者req.files就設定為null object
若有檔案上傳，req.file或者req.files就設定為其檔案的資訊(含目前所在位置)

```
{
    "account":"user2",
    "password":"12345678",
    "confirmPassword": "12345678",
    "email": "belazyuser+2@gmail.com",
    "nickname": "user2",
    "avatar": "https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/52.jpg"
}
```


## 新版的imgurFileHandler

安裝imgur 上傳套件
```
npm install imgur
npm install tslib (Imgur 是ts)
```
https://www.npmjs.com/package/imgur


/helpers/file-upload-helper
```
const { ImgurClient } = require('imgur')
const { code } = require('../config/result-status-table').successTable
const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID
const { createReadStream } = require('fs')
const client = new ImgurClient({ clientId: IMGUR_CLIENT_ID })

async function ImgurFileHandler(file) {
  try {
    const response = await client.upload({
      image: createReadStream(file.path),
      type: 'stream'
    })

    const result = response
    return result.status === code.OK
      ? result.data.link
      : 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1650818850/belazy-shop/Avatar_n1jfi9.png'
  } catch (_) {
    return 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1650818850/belazy-shop/Avatar_n1jfi9.png'
  }
}

exports = module.exports = {
  ImgurFileHandler
}
```

```
const { ImgurFileHandler } = require('../helpers/file-upload-helper')
  async putSelf(req, cb) {
    try {
      const user = getUser(req)
      const message = await updateFormValidator(req)
      if (message.length > 0) {
        return cb(new APIError({ code: code.BADREQUEST, message, data: req.body }))
      }
      const { nickname, email, account, password, avatar } = req.body
      const { file } = req

      let uploadAvatar = ''
      if (avatar === DEL_OPERATION_CODE) {
        uploadAvatar = 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1646039874/twitter/project/defaultAvatar_a0hkxw.png'
      } else {
        uploadAvatar = file?.path
          ? await ImgurFileHandler(file)
          : user.avatar
      }

      await User.update({
        nickname,
        email,
        account,
        password: bcrypt.hashSync(password, DEFAULT_BCRYPT_COMPLEXITY),
        avatar: uploadAvatar
      }, { where: { id: user.id } })

      const resultUser = { ...req.body, avatar: uploadAvatar }
      delete resultUser.password
      delete resultUser.confirmPassword

      return cb(null, resultUser, '修改成功')
    } catch (error) {
      return cb(new APIError({ code: code.SERVERERROR, message: error.message }))
    }
  }

```


> The direct link to the the image. (Note: if fetching an animated GIF that was over 20MB in original size, a .gif thumbnail will be returned)


> The Imgur API returns an error if the user did not grant your application the permissions it requested:
> The error is returned to the application in the query string parameter error if the web server flow is used. 
> If the user agent flow was used, then the error is returned in the fragment. 
> If the state parameter was included in the request, it is also present in the error response.

```
app.post('/profile', upload.single('avatar'), function (req, res, next) {
  // req.file is the `avatar` file
  // req.body will hold the text fields, if there were any
})
```


## 覆寫屬性值
```
const resultUser = { ...req.body, avatar: uploadAvatar } => 可以覆寫掉avatar屬性值
```

```
req.query = { ...req.query, page, limit, order, offset }
```
## 實現分頁的middleware

/middlewares/page-handler.js

```
function orderSetter(order) {
  const resultOrder = order.toUpperCase()
  return ORDER_OPTIONS.includes(resultOrder) ? resultOrder : DEFAULT_ORDER
}

function paging(req, _, next) {
  let { page, limit, order } = req.query

  page = (!isNaN(page) && Number(page)) || DEFAULT_PAGE
  limit = (!isNaN(limit) && Number(limit)) || DEFAULT_LIMIT
  order = order ? orderSetter(order) : DEFAULT_ORDER

  const offset = (page - 1) * limit
  req.query = { ...req.query, page, limit, order, offset }

  return next()
}

exports = module.exports = {
  paging
}
```

應用paging至每個瀏覽功能的middleware上，
```
const { paging } = require('../../middlewares/page-handler')
router.get('/', paging, productController.getProducts)
```