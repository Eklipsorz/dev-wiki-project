---
sidebar_position: 6
---

# 2022-4-27-開發日記

安裝imgur 上傳套件
npm install imgur
npm install tslib (Imgur 是ts)

https://www.npmjs.com/package/imgur

## 舊版：定義imgurFileHandler
為了很好利用第三方所提供的imgur模組，會先載入其模組，並設定其imgur的clientId，接著再新增一個名為imgurFileHandler的檔案處理器，其內部會使用imgur.uploadFile來作為promise來使用，若成功上傳的話，就會回傳代表結果的物件，而物件會有一個名為link的屬性來表示該檔案在imgur的所在位置。

在這裡要考慮到若imgur上傳失敗而導致image為null或者undefined，那麼當系統讀取img.link勢必會報錯中斷後續執行，為了能夠在image為null或者undefined的情況下繼續執行，會使用?.運算元來處理，隨後就決定最後的resolve值為null還是image.link。
```
const imgur = require('imgur')
const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID
imgur.setClientId(IMGUR_CLIENT_ID)
.
.
.
const imgurFileHandler = file => {
  return new Promise((resolve, reject) => {
    if (!file) return resolve(null)
    imgur.uploadFile(file.path)
      .then(img => resolve(img?.link || null))
      .catch(error => reject(error))
  })
}

exports = module.exports = {
  localFileHandler,
  imgurFileHandler
}
```
// catch => status code 不為 200，比如不是imgur所支援的副檔案、imgur無法上傳
// ((img && img.link) || null ) => status 為200 的話，空間不夠就

## 補充：imgur.uploadFile(filePath)
1. uploadFile為imgur套件上傳單一檔案的API之一，會是以一個Promise來實現上傳檔案的功能
2. 主要功能就指定一個要上傳的檔案之所在路徑filePath當作檔案上傳至imgur，在過程中，並不會檢查圖片是否已經存在imgur，而是允許上傳並給新的URI來指向它，所以可以重複上傳多個相同的圖片，而每張相同圖片都有各自的URI
3. 形式會是
```
imgur.uploadFile(filePath)
```

## 補充：optional chaining operator
1. chaining operator A.B 是告知系統將A視作為物件，而B會被系統認為是物件A的屬性B或者方法B，接著系統會從物件A尋找是否有名為B的屬性或者方法，若不存在的話，就回傳undefined，可物件A本身不存在或者會是undefined，系統會無法將null或者undefined當正常物件來存取其屬性而報錯並中斷後續執行

2. 報錯並中斷後續執行的案例：
  - case 1是設定obejct1為null，在處理object1.property時，會因為系統無法將null當正常物件來存取property屬性，所以最後系統會立刻中斷並報出錯誤，在這裏other_code1和之後的程式碼會因為中斷關係而沒被執行
  - case 2是設定object2為undefined，在處理object2.property時，會因為系統無法將undefined當正常物件來存取其property屬性，所以最後系統會立刻中斷並報出錯誤，在這裏other_code2和之後的程式碼會因為中斷關係而沒被執行
```
// case 1
object1 = null
do something with object1.property
other_code1

// case 2
object2 = undefined
do something with object2.property
other_code2
```

3. 而為了解決因存取到的物件為null或者undefined而產生出來的屬性報錯中斷問題，官方有提供optional chaining operator A?.B，當物件A是undefined或者null時，會一率回傳undefined，否則就按照A.B來存取物件A的屬性B



Optional chaining operator:
以下兩者是相等
1. A && A.B
2. A?.B



## Multer
安裝multer
npm install multer
Multer => 負責處理multipart/form-data，尤其是負責弄檔案上傳的部分

Multer:
	- 上傳檔案至本地端，上傳好就設定檔案資訊至req.file或者req.files，若指定存放檔案目錄不存在，就會自動建立目錄

Multer測試：單個檔案上傳時，會是傳哪個屬性
```
 console.log('test file:', req.file, req.files)
```

結果為：
```
test file: {
  fieldname: 'avatar',
  originalname: '*\x16 2022-04-06 \x0BH7.44.32.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'temp/',
  filename: '9a000efa695f056fb4c9695896d09427',
  path: 'temp/9a000efa695f056fb4c9695896d09427',
  size: 99044
} undefined
```
1. 先執行完multiFilesUpload才進入userController.putUser，該multiFilesUpload會先上傳至本地端，putUser路由功能再從本地端上傳至imgur



multiFilesUpload => 
若沒檔案上傳，req.file或者req.files就設定為null object
若有檔案上傳，req.file或者req.files就設定為其檔案的資訊(含目前所在位置)


```
{
    "account":"user2",
    "password":"12345678",
    "confirmPassword": "12345678",
    "email": "belazyuser+2@gmail.com",
    "nickname": "user2",
    "avatar": "https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/52.jpg"
}
```

```
function multer(options) {
  if (options === undefined) {
    return new Multer({})
  }

  if (typeof options === 'object' && options !== null) {
    return new Multer(options)
  }

  throw new TypeError('Expected object for argument options')
}
```

/routes/modules/users.js
```
const { upload } = require('../../helpers/multer-helper')
router.get('/self', userController.getSelf)
router.put('/self', upload.single('avatar'), userController.putSelf)
```
> The direct link to the the image. (Note: if fetching an animated GIF that was over 20MB in original size, a .gif thumbnail will be returned)


> The Imgur API returns an error if the user did not grant your application the permissions it requested:
> The error is returned to the application in the query string parameter error if the web server flow is used. 
> If the user agent flow was used, then the error is returned in the fragment. 
> If the state parameter was included in the request, it is also present in the error response.



```
app.post('/profile', upload.single('avatar'), function (req, res, next) {
  // req.file is the `avatar` file
  // req.body will hold the text fields, if there were any
})
```
## 新版的imgurFileHandler

/helpers/file-upload-helper
```
const { ImgurClient } = require('imgur')
const { code } = require('../config/result-status-table').successTable
const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID
const { createReadStream } = require('fs')
const client = new ImgurClient({ clientId: IMGUR_CLIENT_ID })

async function ImgurFileHandler(file) {
  try {
    const response = await client.upload({
      image: createReadStream(file.path),
      type: 'stream'
    })

    const result = response
    return result.status === code.OK
      ? result.data.link
      : 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1650818850/belazy-shop/Avatar_n1jfi9.png'
  } catch (_) {
    return 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1650818850/belazy-shop/Avatar_n1jfi9.png'
  }
}

exports = module.exports = {
  ImgurFileHandler
}
```

```
const { ImgurFileHandler } = require('../helpers/file-upload-helper')
  async putSelf(req, cb) {
    try {
      const user = getUser(req)
      const message = await updateFormValidator(req)
      if (message.length > 0) {
        return cb(new APIError({ code: code.BADREQUEST, message, data: req.body }))
      }
      const { nickname, email, account, password, avatar } = req.body
      const { file } = req

      let uploadAvatar = ''
      if (avatar === DEL_OPERATION_CODE) {
        uploadAvatar = 'https://res.cloudinary.com/dqfxgtyoi/image/upload/v1646039874/twitter/project/defaultAvatar_a0hkxw.png'
      } else {
        uploadAvatar = file?.path
          ? await ImgurFileHandler(file)
          : user.avatar
      }

      await User.update({
        nickname,
        email,
        account,
        password: bcrypt.hashSync(password, DEFAULT_BCRYPT_COMPLEXITY),
        avatar: uploadAvatar
      }, { where: { id: user.id } })

      const resultUser = { ...req.body, avatar: uploadAvatar }
      delete resultUser.password
      delete resultUser.confirmPassword

      return cb(null, resultUser, '修改成功')
    } catch (error) {
      return cb(new APIError({ code: code.SERVERERROR, message: error.message }))
    }
  }

```


## 覆寫屬性值
```
const resultUser = { ...req.body, avatar: uploadAvatar } => 可以覆寫掉avatar屬性值
```

## 實現分頁的middleware

/middlewares/page-handler.js

```
function orderSetter(order) {
  const resultOrder = order.toUpperCase()
  return ORDER_OPTIONS.includes(resultOrder) ? resultOrder : DEFAULT_ORDER
}

function paging(req, _, next) {
  let { page, limit, order } = req.query

  page = (!isNaN(page) && Number(page)) || DEFAULT_PAGE
  limit = (!isNaN(limit) && Number(limit)) || DEFAULT_LIMIT
  order = order ? orderSetter(order) : DEFAULT_ORDER

  const offset = (page - 1) * limit
  req.query = { ...req.query, page, limit, order, offset }

  return next()
}

exports = module.exports = {
  paging
}
```

應用paging至每個瀏覽功能的middleware上，
```
const { paging } = require('../../middlewares/page-handler')
router.get('/', paging, productController.getProducts)
```