---
sidebar_position: 3
---

# 2022-4-24-開發日記


## 塑造一個特定Error的類別能夠更適用於自己專案下的需求


```
class APIError extends Error {
  constructor(options) {
    super(options.message)
    this.code = options.code
    this.status = options.status
    this.message = options.message
    this.data = options.data
  }
}

exports = module.exports = {
  APIError
}
```

```
if (!account || !password) {
        return cb(new APIError({ code: 403, status: 'error', message: '未填寫完所有欄位' }))
}

if (!user || user.account === 'admin') {
        return cb(new APIError({ code: 404, status: 'error', message: '帳號不存在' }))
}
```


```
function APIErrorHandler(error, _, res, next) {
  const DEFAULT_STATUS = 'error'
  const DEFAULT_CODE = 500
  const DEFAULT_MESSAGE = '系統出錯'
  const DEFAULT_DATA = null

  const code = error.code || DEFAULT_CODE
  const message = error.message || DEFAULT_MESSAGE
  const status = error.status || DEFAULT_STATUS
  const data = error.data || DEFAULT_DATA

  switch (error.code) {
    case 400:
    case 401:
    case 403:
    case 404:
    case 500:
      res.status(code).json({ status, message, data })
      break
  }
  next(error)
}

exports = module.exports = {
  APIErrorHandler
}
```

## 從 controller 切分 services
```
const userController = {
  login: (req, res, next) => {
    userServices.login(req, (error, message, data) =>
      error ? next(error) : res.status(200).json({ status: 'success', message, data })
    )
  }
}
```


```
const userServices = {
  login: async (req, cb) => {
    ....
  }
}

exports = module.exports = {
  userServices
}
```

https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript




## 沒用到的參數可用_代替

function APIErrorHandler(error, _, res, next) {

}


## Spread syntax 運用於物件
Spread syntax (...)
Try it

展開運算子(...) 允許可迭代的陣列或字串展開成０到多個參數(如果是function的話)或是０到多個元素(如果是array或字組的話)，或如果是物件的話則展開成０到多個key-value pair。

const obj1 = {
  name: 'ah',
  date: 'awe23'
}

const obj2 = { ...obj1 }

console.log(obj2)
{ name: 'ah', date: 'awe23' }



## 補充：Eagerly load

Eager loading：

- eager 表示當需求來臨時，強調某些人事物迫切地需要某些人事物，搭配 loading 代表著當需求來臨時，迫切地需要某些人事物的 loading，或者指當需求來臨時，迫切地載入所有內容，
- 在 sequelize 中的 Eager loading 則是指的先用到的資料先用 SQL 語法取出並放入特定空間，好與其他資料進行處理。
-  eager loading，是預先加載的意思，也就是在用到資料前就先去資料庫把資料取出來，存在變數中。
- 理論案例：在這裏Eager loading會先處理B和處理function(C)來載入他們的值，接著等到正式做+時，就直接以結果進行相加
```
A = B + function(C)
```
- Earger loading 的 Sequelize 案例為：

```
const awesomeCaptain = await Captain.findOne({
  where: {
    name: "Jack Sparrow"
  },
  include: Ship
});
// Now the ship comes with it
console.log('Name:', awesomeCaptain.name);
console.log('Skill Level:', awesomeCaptain.skillLevel);
console.log('Ship Name:', awesomeCaptain.ship.name);
console.log('Amount of Sails:', awesomeCaptain.ship.amountOfSails);
```

Lazy loading：

- 相對於 Eagerly loading，Lazy 表示當需求來臨時，強調某些人事物並不會迫切地需要人事物，等到真正要處理的時候才會去做需要這動作，搭配 loading 代表著當需求來臨時，不會迫切地需要人事物的 loading，或者指當需求來臨時，並不會先去 loading 需要的內容，而是等到真正要處理的時候才會去做 loading 的動作
- 在 sequelize 中的 Lazy loading 則是指的先用到的資料不會先用 SQL 語法取出並放入特定空間，而是等到真正需要存取該資料的時候才會用 SQL 語法去處理

- 理論案例：在這裏Lazy loading會從B開始處理，接著處理function(C)並載入其回傳值，最後再拿B和function(C)進行相加，不會像Eager loading先處理獲取B和載入function(C)的回傳值
```
A = B + function(C)
```
- Lazy loading 的 Sequelize 案例為：

```
const awesomeCaptain = await Captain.findOne({
  where: {
    name: "Jack Sparrow"
  }
});
// Do stuff with the fetched captain
console.log('Name:', awesomeCaptain.name);
console.log('Skill Level:', awesomeCaptain.skillLevel);
// Now we want information about his ship!
const hisShip = await awesomeCaptain.getShip();
// Do stuff with the ship
console.log('Ship Name:', hisShip.name);
console.log('Amount of Sails:', hisShip.amountOfSails);
```

參考資料：

- [what-is-eager-loading](https://stackoverflow.com/questions/1299374/what-is-eager-loading)
- [eager-loading-and-lazy-loading](https://chuyi.inow.tw/2013/02/eager-loading-and-lazy-loading/)

## 從sequelize 語法中轉為json
 將結果轉為json
db.Sensors.findAll({
  where: {
    nodeid: node.nodeid
  },
  raw: true,
})

## 保留原始結果
 按照所需從結果裡取出值並依照需求取名字，並保留原始結果的名稱和用途保持在中性，比如利用資料庫找到對應user，但為了滿足回傳使用者資訊的需求，而取一個別名為resultUser 來表明目前結果會是個自己所需的，但同時也保留user這個原始結果

```
      const user = await User.findOne({ where: { account }, raw: true })

      if (!user || user !== 'admin') {
        return cb(new APIError({ code: 404, status: 'error', message: '帳號不存在' }))
      }
      if (!bcrypt.compareSync(password, user.password)) {
        return cb(new APIError({ code: 403, status: 'error', message: '帳號或密碼不正確' }))
      }
      const resultUser = user
```