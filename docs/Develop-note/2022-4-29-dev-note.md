---
sidebar_position: 8
---

# 2022-4-28-開發日記


## seeder 開發邏輯
在這裡主要會以sequelize所建立的seeder來進行開發，其中seederName會是開發者自定的seeder名稱，建立完畢後，系統會將目前時間戳附加至前面訂下的名稱來構成該seeder檔案的名稱，

```
npx sequelize seed:generate --name seederName
```
若要執行下面指令來執行所有seeder，就會依據時間的先後順序來執行(從早至晚)。

```
npx sequelize db:seed:all 
```
每一個seeder皆有up和down函式，up是每一次執行該seeder就呼叫，down 是每一次執行該seeder的undo就呼叫，在這裡的開發，我設定每個seeder都綁定於一個表格並且開發上盡量以目標表格為主，不去影響/更動其他表格的內容，以保持SoC(Separation of concerns，SoC)的目標。


由於這樣，每一次做undo時就只需要刪去每個seeder所綁定的表格就能達成目標-退回做seeder的狀態，down函式具體內容會像是
```
await queryInterface.bulkDelete(tableName)
```

而up函式則是依據每一個seeder目標來寫

### user seeder
目標產生一個管理員和二十名一般使用者

在這裡先定義幾個全域變數來產生使用者所需要的預設密碼、加密複雜度、電子郵件前綴、電子郵件後綴、一般使用者數量
```
const {
  // User
  DEFAULT_PASSWORD,
  DEFAULT_BCRYPT_COMPLEXITY,
  DEFAULT_EMAIL_PREFIX,
  DEFAULT_EMAIL_SUFFIX,
  DEFAULT_USER_NUMBER
} = require('../../config/app').seeder.usersSeeder
```

具體開發流程為：
```
    // 先設定seederArray 並設定預設值，用以物件的形式來定義要生成的seed data為何，並同時保持獨立區塊：設定預設值和實際運用該變數這兩個區塊
    const seederArray = []

    // add an admin account
    // 新增一筆管理員帳號至seederArray
    seederArray.push({
      account: 'admin',
      password: bcrypt.hashSync(DEFAULT_PASSWORD, DEFAULT_BCRYPT_COMPLEXITY),
      role: 'admin',
      email: `${DEFAULT_EMAIL_PREFIX}0@${DEFAULT_EMAIL_SUFFIX}`,
      avatar: faker.image.avatar(),
      nickname: 'admin',
      created_at: new Date(),
      updated_at: new Date()
    })

    let userArray = []
    // add n users account (n => DEFAULT_USER_NUMBER)
    // 建立一個假的可迭代物件(擁有length屬性)來產生n個使用者的資料並存放陣列


    // 新增一個使用者陣列userArray ，每一個在陣列的元素皆會以from夾雜的map function來構成，
    // 換言之，每一個元素皆轉為擁有帳號、密碼等資訊的物件，然後再以一個陣列來儲存這些物件
    userArray = Array.from({ length: DEFAULT_USER_NUMBER }, (_, index) => ({
      account: `user${index + 1}`,
      password: bcrypt.hashSync(DEFAULT_PASSWORD, DEFAULT_BCRYPT_COMPLEXITY),
      role: 'user',
      email: `${DEFAULT_EMAIL_PREFIX}${index + 1}@${DEFAULT_EMAIL_SUFFIX}`,
      avatar: faker.image.avatar(),
      nickname: `user${index + 1}`,
      created_at: new Date(),
      updated_at: new Date()
    }))
    // 最後將userArray新增至seederArray
    seederArray.push(...userArray)
    // 執行bulkInsert將最後結果的seederArray當參數執行，產生對應seed data
    await queryInterface.bulkInsert('users', seederArray)
```

### category seeder
目標為依據種類名稱和圖片的設定來定義8個產品種類

在這裡先定義幾個全域變數來產生種類所需要的種類數量、實際指定每個種類所要的名字和對應圖片
```
const {
  DEFAULT_CATEGORY,
  DEFAULT_CATEGORY_NUMBER
} = require('../../config/app').seeder.categoriesSeeder
```
具體開發流程為：

```
    // 先設定seederArray 並設定預設值，用以物件的形式來定義要生成的seed data為何，並同時保持後續開發皆會從預設值設定之後開始
    const seederArray = []
    // 新增一個種類陣列categoryArray ，每一個在陣列的元素皆會以from夾雜的map function來構成，
    // 換言之，每一個元素皆轉為擁有名稱、圖片等資訊的物件，然後再以一個陣列來儲存這些物件
    const categoryArray = Array.from({ length: DEFAULT_CATEGORY_NUMBER }, (_, i) => ({
      name: DEFAULT_CATEGORY[i].name,
      image: DEFAULT_CATEGORY[i].image,
      created_at: new Date(),
      updated_at: new Date()
    }))
    // 最後將categoryArray新增至seederArray
    seederArray.push(...categoryArray)
    // 執行bulkInsert將最後結果的seederArray當參數執行，產生對應seed data
    await queryInterface.bulkInsert('categories', seederArray)
```

### product seeder

目標為產生100個產品

首先先用全域變數來定義要產生的產品總數和價格範圍
```
const { productsSeeder } = require('../../config/app').seeder
```

具體開發流程為：
```
    // 先設定seederArray 並設定預設值，用以物件的形式來定義要生成的seed data為何，並同時保持後續開發皆會從預設值設定之後開始
    const seederArray = []
    // 從productsSeeder獲取對應產品總數和價格範圍這兩者的設定。
    const { DEFAULT_PRODUCT_NUMBER, DEFEAULT_PRICE } = productsSeeder
    const { MAX, MIN } = DEFEAULT_PRICE
    const productNum = DEFAULT_PRODUCT_NUMBER
    // 新增一個種類陣列productArray ，每一個在陣列的元素皆會以from夾雜的map function來構成，
    // 其中價格和數量會透過DEFAULT_PRODUCT_NUMBER, DEFEAULT_PRICE 來設定，
    // 換言之，每一個元素皆轉為擁有名稱、圖片等資訊的物件，然後再以一個陣列來儲存這些物件
    const productArray = Array.from({ length: productNum }, (_, i) => ({
      name: faker.name.firstName().substring(0, 30),
      introduction: faker.lorem.paragraph().substring(0, 255),
      price: Math.floor(Math.random() * (MAX - MIN) + 1) + MIN,
      image: `https://loremflickr.com/320/240/product?lock=${(Math.random() * 100) + 1}`,
      created_at: new Date(),
      updated_at: new Date()
    }))

    // 最後將productArray新增至seederArray
    seederArray.push(...productArray)
    // 執行bulkInsert將最後結果的seederArray當參數執行，產生對應seed data
    await queryInterface.bulkInsert('products', seederArray)
```

### ownership seeder



### like seeder

### reply seeder

### stock seeder

目標為替每一個由product seeder產生出來的產品生成對應庫存資料，換言之，在另一個表格紀錄著每一個產品的庫存量和剩餘庫存量


首先先用全域變數來定義每個產品具體庫存量和剩餘庫存量為啥
```
const { stockSeeder } = require('../../config/app').seeder
// stockSeeder.DEFAULT_QUANTITY = {
//    SUM: ...., 總數
//    REST: .... 剩餘量
// }
```
具體開發流程為：
```
    // 先設定seederArray 並設定預設值，用以物件的形式來定義要生成的seed data為何，並同時保持後續開發皆會從預設值設定之後開始
    const seederArray = []

    // 獲取所有產品
    const seedProducts = (await queryInterface.sequelize.query(
      'SELECT id FROM products',
      { type: queryInterface.sequelize.QueryTypes.SELECT }
    )).map(item => item.id)
    // 設定每個產品的庫存和剩餘庫存
    const stockArray = []
    // 從stockSeeder獲取每個產品具體庫存量和剩餘庫存量為啥
    const { DEFAULT_QUANTITY } = stockSeeder

    // 新增一個種類陣列productArray ，每一個在陣列的元素皆會以from夾雜的map function來構成，
    // 其中庫存量和剩餘庫存量會透過DEFAULT_QUANTITY的SUM屬性和REST屬性來設定，
    // 換言之，每一個元素皆轉為擁有產品id、數量、剩餘量等資訊的物件，然後再以一個陣列來儲存這些物件
    seedProducts.forEach(productId => {
      stockArray.push({
        product_id: productId,
        quantity: DEFAULT_QUANTITY.SUM,
        rest_quantity: DEFAULT_QUANTITY.REST,
        created_at: new Date(),
        updated_at: new Date()
      })
    })
    // 最後將stockArray)新增至seederArray
    seederArray.push(...stockArray)

    // 執行bulkInsert將最後結果的seederArray當參數執行，產生對應seed data
    await queryInterface.bulkInsert('stock', seederArray)
```


### prodcut-statistic

### user-statistic
