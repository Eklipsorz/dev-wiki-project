---
sidebar_position: 4
---

# 2022-4-25-開發日記


Javascript 


https://segmentfault.com/q/1010000008718054

## class 下的 super
每一個沒有繼承類別的類別本身可以依據建構式和建構式呼叫來建立屬於自己的實體物件或者屬於自己的this，
```
class ClassX {
  // 定義建構式
  constructor(prop) {
    this.prop = prop
  }
}

// 呼叫ClassX下的constructor來建立對應ClassX的實例物件。
new ClassX(prop)
```

然而若讓某類別X去繼承另一個類別Y，那麼類別Y就是類別X的父類別，而類別X是類別Y的子類別，而子類別的建構式卻不能夠像上面那樣，因為子類別本質上的實作依據著父類別的實體物件來延伸自己屬性，所以若沒有直接呼叫父類別的建構式會違反上述而報錯
```
class ClassX extends ClassY {
  constructor(prop) {
    this.prop1 = prop
  }
}
// ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
new ClassX(prop)
```

解法為super()是呼叫父類別的建構式並建立父類別的實例物件以構成子類別的基本實例物件，後續子類別所獨有的屬性和方法，就依據父類別的物件來延伸

```
class ClassX extends ClassY {
  constructor(prop) {
    super(prop)
  }
}
new ClassX(prop)
```

參考資料：
[typescript的super到底是用来干什么的？](https://segmentfault.com/q/1010000008718054)

## callback的編碼風格
風格為error-first callback，在這個風格下是：
1. 第一個參數會是代表該callback執行錯誤時的錯誤資訊
> The first argument in the function is reserved for the error object. If any error has occurred during the execution of the function, it will be returned by the first argument.
2. 第二個參數會是代表callback執行成功時所回傳過來的處理結果，若沒有處理結果可設定為null
> The second argument of the callback function is reserved for any successful data returned by the function. If no error occurred then the error object will be set to null.
3. 若callback執行是成功的話，第一個參數勢必為null。

```
 (error, data, message) =>
      error ? next(error) : res.status(code.OK).json({ status, message, data })
  )
```
參考資料：
[Error-First Callback in Node.js](https://www.geeksforgeeks.org/error-first-callback-in-node-js/)
## validator
Validator 是一個模組，本身用途為：
  - 按照通用字串驗證規則來驗證字串是否合法
  - 提供一些解法來試著通過自身的字串驗證規則


安裝validator.js，方式如下：
```
npm i validator
```


## error物件無法接受陣列型態的message
在這裡由於error物件的建構式接受的訊息參數得是一般字串，若是將陣列資訊輸入給該建構式，會被裡頭的強制轉換給轉換成字串來輸入和設定子類別的message為字串，為了避免這樣子的字串轉換，而在super之後多添加了以下程式碼，來以一般指派處理來將陣列輸入給message屬性
```
super(options.message)
this.message = message
```

整體會像是如下：
```
class APIError extends Error {
  constructor(options) {
    super(options.message)
    this.code = options.code
    // 這句不是多餘的，由於error只能接受字串，所以若是把陣列丟進去會強制轉換為字串，所以得在事後多設定陣列至message
    this.message = options.message
    this.status = options.status
    this.data = options.data
  }
}
```

## 狀態碼轉換成可讀性高的文字
由於magic number對於人類來說，勢必是額外花些時間去理解數字背後的意義，為了避免這樣的數字出現，而盡可能將magic number的出現次數降低：透過狀態碼轉換成對應狀態碼訊息來實現，在這裡首先先於/config/result-status-table.js定義整體的成功和失敗之狀態碼 ，並讓整個專案載入該檔案，來按照數字來填入對應的代碼訊息，讓整體專案變得相當好讀取
```
const errorTable = {
  status: 'error',
  code: {
    BADREQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOTFOUND: 404,
    SERVERERROR: 500
  }
}
const successTable = {
  status: 'success',
  code: {
    OK: 200
  }

}
exports = module.exports = {
  errorTable,
  successTable
}
```

成功訊息載入
```
const {
  status,
  code
} = require('../config/result-status-table').successTable

const userController = {
  login: (req, res, next) => {
    accountServices.login(req, 'users', (error, data, message) =>
      error ? next(error) : res.status(code.OK).json({ status, message, data })
    )
  },
}
```

失敗訊息載入
```
const {
  status,
  code
} = require('../config/result-status-table').errorTable

if (!account || !password) {
    return cb(new APIError({ code: code.FORBIDDEN, status, message: '未填寫完所有欄位' }))
}
```

## 專注寫特定Domain下的業務邏輯

/config/service.js
```
const accountService = {
  blackListRoleIn: {
    users: ['admin'],
    admin: ['user']
  }
}

exports = module.exports = {
  accountService
}
```


/services/account-service.js
```
const {
  blackListRoleIn
} = require('../config/service').accountService

const accountServices = {
  login: async (req, type, cb) => {
    if (!user || blackListRoleIn[type].includes(user.role)) {
        return cb(new APIError({ code: code.NOTFOUND, status, message: '帳號不存在' }))
    }
  }
}
```

## 讓控制器直接對接業務邏輯

/controllers/admin-controller.js
```
const adminController = {
  login: (req, res, next) => {
    accountServices.login(req, 'admin', (error, data, message) =>
      .....
    )
  }
}
```

/controllers/user-controller.js
```
const userController = {
  login: (req, res, next) => {
    accountServices.login(req, 'users', (error, data, message) =>
      .....
    )
  }
}
```




