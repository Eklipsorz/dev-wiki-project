---
sidebar_position: 24
---

# u53-58 新知和技術


## Mongoose 會自己建立對應的資料庫
1. 


## Mongoose 對於非同步處理提供三種形式來調用
1. Callback ：當非同步處理處理完時，就會執行Callback的內容
2. Promise：當非同步處理完時，會以Microtask的形式執行
3. Async/await：Promise的語法糖


## mongoose.connect(…)
1. 本身是非同步處理，可以是：
  - promise
  - callback
  - Async/await
2. Promise 當成功連線時，就會以連線狀態和資訊來執行resolve，否則當連線失敗時，就會reject
3. 細節：
  - 當mongoose.connect連線的資料庫是不存在時，會自動在MongoDB上建立對應的資料庫

## mongoose.connection 
1. 本身會參照著Mongoose.connect回傳的promise結果，當調用以下語法時，connection是不會立即獲得連線結果，只會拿到pending狀態的promise，等到connect成功時，db就會透過參照獲取該promise的狀態和資訊。
```
mongoose.connect(....)
const db = mongoose.connection
```

2. 通常會搭配著事件處理，等到其結果觸發特定事件來執行。


## 建立兩名使用者和所屬餐廳

1. Callback：
```
// 透過users.entries建立專屬於使用者陣列的迭代器，
// 其中每一次迭代回傳的內容為 {value: [key, value], done: false/true}
// 在這裡為兩個使用者，所以分別為
// {value: [0, value0], done: false}
// {value: [1, value1], done: true}
// 在這裡透過for-of從中取得使用者陣列的迭代器，並因為兩個使用者調用兩次next()來獲取value
// value會是由key和value所組成的[key, value]陣列
// 透過[user_index, user] 來解構從中獲得key, value
for (const [user_index, user] of users.entries()) {

    // 向資料庫系統發送建立一個使用者的請求，接著賦予它一個callback，讓它建立完使用者就執行callback
    UserModel.create(user, (err, user) => {
      // 決定每一個使用者所會用到的餐廳id
      const userRestaurant = []
      // rest_index會是指每一次迭代的索引值，一開始會從0計數
      restaurants.forEach((restaurant, rest_index) => {
        if (rest_index >= 3 * user_index && rest_index < 3 * (user_index + 1)) {
          restaurant.userId = user._id
          userRestaurant.push(restaurant)
        }
      })
      // 根據每個使用者所擁有的餐廳來建立餐廳請求並發送資料庫系統，接著賦予它一個callback，讓它
      // 建立完餐廳就執行callback
      RestaurantModel.create(userRestaurant, () => {
        console.log("restaurant created")
      })
    })
  }
```

2. Promise 風格：為了近一步根據使用者和餐廳是否建立來關閉資料庫的連線，而使用Promise包覆著使用者和餐廳這兩者的建立請求，當使用者和餐廳一被建立完就會執行resolve來給予後續的then來讓其得知前一個promise已經是fulfilled狀態，接著就能在then內部執行資料庫關閉或者程式停止執行的程式碼。
```
new Promise((resolve, _reject) => {
    for (const [user_index, user] of users.entries()) {
      // 創建使用者資料(user): model.create
      UserModel.create({
        ...user
      }).then((user) => {
        // 對每個user建立相對應餐廳資料
        return RestaurantModel.create(restaurants)
      }).then(() => {
        resolve()
      }).catch(error => {
        console.log(error)
      })
    }
  }).then(() => {
    // 等待所有使用者的餐廳資料創建完成
    console.log('所有使用者與餐廳資料創建完成')
    process.exit()
  })
```