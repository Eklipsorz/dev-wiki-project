---
sidebar_position: 77
---

# u152 新知和技術



## 餐廳列表分頁功能

實作分頁器主要要考慮如何將資料篩選成指定頁數中所會有的資料，為了達到這樣，我們可以先假設每一頁會有十筆餐廳，第一頁會是前面第一筆至第十筆餐廳，第二頁則會是跳過前面十筆餐廳，直接挑選第十一筆餐廳至第二十筆餐廳，第三頁則會是跳過前面二十筆餐廳，直接挑選第二十一筆餐廳至第三十筆餐廳，後面以此類推，假如有一頁未滿十筆餐廳就以當前餐廳數量來呈現，總結這幾項觀察，具體可以是：
  - 定義page這個參數來表示第n頁
  - 要呈現第n頁內的內容，會是跳過前面n-1頁的所有內容並按照指定餐廳數量於當前餐廳挑選前幾筆餐廳

除了實際呈現第n頁的內容以外，還得考量到目前頁數所能到達的範圍以及符合目前資料的目前頁數，總結來說的話，要實現分頁功能，會需要照料：
  - 渲染頁數本身部分
  - 實際按照頁數來呈現資料

## 渲染頁數本身部分
在這個部分，會使用bootstrap的pagination樣式來實作分頁器整體部分，內容會利用page-item來建立左右箭頭、數字來分別呈現目前頁數的前一頁、目前頁數的後一頁、能選的頁數，此外，這一個部分都有些細節需要考慮：
  - 左箭頭呈現目前頁數的前一頁：由於使用者透過點選左箭頭就能到達目前頁數的前一頁，但如果前一頁是超出分頁器所能代表的，也就是從第1頁轉移至第0頁或者第0頁轉移至第-1頁，為了盡可能避免會添加ifCond 判別目前頁數是否為1來設定disabled來防止使用者超出頁數
  - 右箭頭呈現目前頁數的後一頁：由於使用者透過點選右箭頭就能到達目前頁數的後一頁，但如果後一頁是超出分頁器所能代表的，也就是從第最後一頁轉移至第最後一頁+1頁，為了盡可能避免會添加ifCond 判別目前頁數是否為總頁數來設定disabled來防止使用者超出頁數
  - 能選的頁數：判斷使用者點選的頁數是否與當前所代表的頁數相符，若相符就表示active，若不相符就不表示。
```
<nav class="mt-3" aria-label="page navigation">
  <ul class="pagination">
    <!-- 呈現左箭頭，並綁定目前頁數的前一頁 -->
    <li class="page-item {{#ifCond pagination.currentPage 1}}disabled{{/ifCond}}">
      <a class="page-link" href="/restaurants?page={{pagination.prev}}&categoryId={{categoryId}}" aria-label="Previous">
        <span aria-hidden="true">&laquo;</span>
      </a>
    </li>

    <!-- 呈現每一頁的狀態 -->
    {{#each pagination.pages}}
      {{#ifCond this ../pagination.currentPage}}
        <li class="page-item active"><a class="page-link" href="#">{{this}}</a></li>
      {{else}}
        <li class="page-item">
          <a class="page-link" href="/restaurants?page={{this}}&categoryId={{../categoryId}}">{{this}}</a>
        </li>
      {{/ifCond}}
    {{/each}}

    <!-- 呈現右箭頭，並綁定目前頁數的後一頁 -->
    <li class="page-item {{#ifCond pagination.currentPage pagination.totalPage}}disabled{{/ifCond}}">
      <a class="page-link" href="/restaurants?page={{pagination.next}}&categoryId={{categoryId}}" aria-label="Next">
        <span aria-hidden="true">&raquo;</span>
      </a>
    </li>
  </ul>
</nav>
```

新增 helper

我們打算建立一個分頁專用的 helper，專門來處理分頁相關的邏輯，請到 helpers 資料夾底下建立一個新檔案：

touch helpers/pagination-helper.js

## 補充： sequelize 的 findAndCountAll 功能
1. 列屬於sequelize finder類型的函式，其中語法為如下，options會與finder中的findAll一樣，而回傳的promise會夾雜兩種主要屬性的物件，其屬性分別為結果紀錄所擁有的數量-count和一個由所有結果紀錄所構成的陣列
```
 findAndCountAll(options: object): Promise
```
2. 舉例：假如要計算目前類別有多少筆紀錄且要獲取其每筆紀錄內容，會使用findAndCountAll並用raw來整頓資料，而該promise所回傳的promise會傳一個物件，其結果會跟Category.findAll({ raw: true})一樣，只是多了一個count屬性來得知類別紀錄總筆數，所以在這我們可以透過這物件來印出類別有幾筆以及詳細內容為何
```
    Category.findAndCountAll({ raw: true })
      .then(categories => {
        console.log('Category counts', categories.count, categories)
    })
```

## 補充： sequelize 的 limit 和 offset
1. limit 會是對應 SQL limit 語法，主要功能為將Query的最後結果縮減至n個紀錄，而n個紀錄會是原紀錄中的前n個紀錄，語法會是如下，limit會是對應語法的關鍵字，而n正是目標要縮減的數量
```
model.finder({
  .
  limit: n,
  .
})
```
2. offset 則是對應著 SQL offset 語法，主要功能為將Query的最後結果去掉前n個紀錄，語法會是如下，offset會是對應語法的關鍵字，而n正是目標要去掉的數量
```
model.finder({
  .
  offset: n,
  .
})
```
3. 若將limit m 和offset n 結合著使用，會是將Query的最後結果會先被去掉前n個紀錄，再來從中取前面m個紀錄當作最後結果，舉例：對著Project對應的資料表格獲取所有project，並將其結果先去掉前面4個紀錄，接著隨後再取前面五個紀錄當作Project.findAll的結果。
```
Project.findAll({
  offset: 4,
  limit: 5
})
```


## 補充： what is magic number? && anti-pattern
1. magic number：
  - 單方面透過數字本身以及獨特性當做參數來產生出不同結果和功能，數字本身也未被賦予特定意義或者它代表著什麼樣功能，就只是依照數字原有的型態來呈現它就是數字
  - 由於magic number本身依據著獨特且數字原有形態來表達功能的不同，這對人類而言，會很難閱讀、理解、維護，但卻可以解決問題，所以是一種anti-pattern的解決方案
  - 由於magic number本身是獨特且數字原有型態來呈現，可以在帳號系統用來辨識每個使用者的不同。
> The term magic number or magic constant refers to the anti-pattern of using numbers directly in source code.


2. software design pattern : software是指軟體開發，而desgin pattern則是設計方法，合併起來就是軟體開發方面的設計方法，泛指如何在不同場景下要怎麼解決問題的一種方案，會將開發問題、解法、場景轉換成一個可分析思考的架構，以試著找出可讀性、維護性、擴充性極高的解決方案來面對問題。
> is a general, reusable solution to a commonly occurring problem within a given context in software design
>  common approaches to common problems which have been formalized and are generally considered a good development practice, anti-patterns are the opposite and are undesirable
3. anti-pattern：
  - 同樣也是一種software design pattern
  - 只是anti在這裡的含義是相悖於design pattern存在的意義-找出可讀性、維護性、擴充性極高的解決方案，anti-pattern是為了找出有哪種解決方案會是能解決問題，但其可獨性、維護性、擴充性很差，以此當作測試代碼的基礎，檢驗代碼是否滿足於anti-pattern。
  - 主要用作於測試代碼是否存在anti-pattern的解法或者當作負面教材來校正程式碼不去滿足於anti-pattern

4. pattern：一個如何將某件事物完成、某件事物組織起來、引發某件事件發生的特定方法
> a particular way in which something is done, is organized, or happens
[what-is-an-anti-pattern](https://stackoverflow.com/questions/980601/what-is-an-anti-pattern)