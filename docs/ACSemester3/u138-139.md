---
sidebar_position: 63
---


# u138-139 新知和技術  




## 設定餐廳類別的資料關聯
為了讓每家餐廳都擁有自己的餐聽類別，在這裡會需要完成：
1. 新建 Category Model
2. 設定 Model 關聯
3. 幫 Restaurant 加上 CategoryId 欄位


### 新建 Category Model
首先新增對應類別的Model和其資料表格，在這裏我們會將Model名稱取名為Category，而屬性會有字串型別的name，整個Model會是以underscored來自動轉換。
```
npx sequelize model:generate --name Category --attributes name:string --underscored
```
### 設定 Model 關聯

單方面從Category來定義自己與Restaurant之間的關聯為一對多關係，並拿自己主鍵來當Restaurant的外鍵-categoryId。
```
  class Category extends Model {
    static associate (models) {
      Category.hasMany(models.Restaurant, { foreignKey: 'categoryId' })
    }
  }
```

單方面從Restaurant來定義自己與Category之間的關聯為一對一關係，並設定自己的屬性categoryId為外鍵，且是由Restaurant的主鍵所構成的外鍵
```
  class Restaurant extends Model {
    static associate (models) {
      Restaurant.belongsTo(models.Category, { foreignKey: 'categoryId' })
    }
  }
```

### 幫 Restaurant 加上 CategoryId 欄位
設定 Model 關聯本身只是定義Model之間的關係是為何以及外鍵是哪個屬性，但實際上並不會建立外鍵，因此在這必須手動增加該外鍵的欄位名稱。具體在這裡會先產生一個migration檔案來在現有schema以及紀錄下增加一個屬性
```
  npx sequelize migration:generate --name add-category-id-to-restaurant
```
其migration檔案名稱為xxxx-add-category-id-to-restaurant.js，在內部的up函式添增，由於該migration檔案會直接使用SQL語言來與資料庫做操作，所以一切的欄位、表格名稱皆必須以資料庫的命名方式來進行：
  - 在名為Restaurants資料表格中增加category_id這欄位
  - category_id型別為整數型別、不允許為空、且參照於Categories資料表格中的id主鍵為其外鍵的構成
```
await queryInterface.addColumn('Restaurants', 'category_id', {
      type: Sequelize.INTEGER,
      allowNull: false,
      references: {
        model: 'Categories',
        key: 'id'
      }
    })
```

### 在現有資料的情況下更改model對應的表格之schema
寫完migration檔案並執行對應檔案
```
npx sequelize db:migrate
```

隨後會出現以下錯誤訊息
```
ERROR: Cannot add or update a child row: a foreign key constraint fails (`forum`.`#sql-85_9a`, CONSTRAINT `Restaurants_category_id_foreign_idx` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`))
```

ERROR 的主因是 Restaurants table 中已經有 50 筆餐廳資料了，若在這個情況下替對應表格增加不允許空值的category_id欄位，且沒給有預設值，會直接報錯，但即使給定預設值，還是因為其外鍵所根據主鍵值並沒有該預設值，也就是說，目前還沒有類別可以讓餐廳的外鍵參照。

在這裡選擇的方案為由於目前資料全是種子資料，所以可以先刪除再重新執行migration檔案，這樣子成功建立對應的資料表格，但必須重新改寫種子資料。
```
$ npx sequelize db:seed:undo
$ npx sequelize db:migrate
```



若在現有資料的情況下更改model對應的表格之schema，系統很有可能因為新的schema限制而無法成功依照新的schema來建立對應表格，為了要解決這個問題，有幾種解決方案：
  - 把 allowNull 暫時改為 true ，之後再改回去
  - 先指定一個預設值給這個欄位，例如 defaultValue: 1
  - 先備份其資料表格的資料，再重新刪掉其schema來塑造更新後的表格




## 補充：關聯和外鍵
當我們新增兩個對應資料表格的model時，若想在應用程式層面的Model上替這兩個model建立一對一、一對多、多對多這些關係的話，會做以下事情：
1. 定義關係：在對應的Model檔案中，替每一個類別下的靜態方法-associate(如下)來定義著該ModelA與其他ModelB的關係，具體來說會使用著hasOne()、belongsTo、hasMany()、belongsToMany()分別在ModelA和ModelB定義關係
```
 class ModelA extends Model {
    static associate (models) {
      // define association here
    }
  };
```
2. 定義哪個屬性為外鍵：定義關係完畢之後，並不表示完全實現關係所要有的功能，只是純粹定義誰跟誰的關係是如何，還需要定義著哪些屬性是外鍵，透過定義外鍵來加速查詢速度和方便驗證紀錄的好壞，具體會在hasOne()、belongsTo、hasMany()、belongsToMany()的調用上進一步定義著哪個屬性是外鍵，另外當設定完外鍵時，並不會自動建立該外鍵屬性，必須手動建立該欄位：
  - 若 ModelA 與 ModelB 是一對一關係的話，其外鍵設定為：
  ```
  // 單方面定義從ModelA的角度來與ModelB呈現為一對一關係，且用ModelA的主鍵來當ModelB的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelA.hasOne(models.ModelB, { foreginKey: foreginKey1 })

  // 單方面定義從ModelB的角度來與ModelA呈現為一對一關係，且用ModelB的主鍵來當ModelB的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelB.belongsTo(models.ModelA, { foreginKey: foreginKey1 })
  ```
  - 若 ModelA 與 ModelB 是一對多關係的話，其外鍵設定為：
  ```
  // 單方面定義從ModelA的角度來與ModelB呈現為一對多關係，且用ModelA的主鍵來當ModelB的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelA.hasMany(models.ModelB, { foreginKey: foreginKey1 })

  // 單方面定義從ModelB的角度來與ModelA呈現為一對一關係，且用ModelB的主鍵來當ModelB的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelB.belongsTo(models.ModelA, { foreginKey: foreginKey1 })
  ```
  - 若 ModelA 與 ModelB 是多對多關係的話，會額外建立一個對應另一個資料表格的ModelC來實現前兩者的Model的多對多關係，並且用ModelA和ModelB的主鍵來當ModelC的外鍵，其外鍵設定為：
  ```
  // 單方面定義從ModelA的角度來與ModelC呈現為一對多關係，且用ModelA的主鍵來當ModelC的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelA.belongsToMany(models.ModelB, { through: ModelC, foreginKey: foreginKey1 })

  // 單方面定義從ModelB的角度來與ModelC呈現為一對多關係，且用ModelB的主鍵來當ModelC的外鍵，
  // 其外鍵屬性名稱會是foreginKey1
  ModelB.belongsTo(models.ModelA, { foreginKey: foreginKey1 })
  ```
3. 實際建立外鍵屬性：
  - 建立對應的migration檔案並執行，其內容為如下，若ModelA與ModelB之間建立關係，並設定將ModelA的主鍵設定為ModelB的外鍵的話，會是如以下來設計
  ```
  up: async (queryInterface, Sequelize) => {
      await queryInterface.addColumn(ModelB, foreignKey1, {
        type: Sequelize.INTEGER,
        // 不允許空值
        allowNull: false,
        // 設定該欄位參考於哪個model和該model下的哪個欄位
        references: {
          model: ModelA ,
          key: key1
        }
      })
    }
  ```
4. 細節：
  - 若單方面定義外鍵的存在，卻沒指定誰是外鍵(如下)，會讓sequelize沒辦法完全實現外鍵本身會有的功能，可能不會有外鍵帶來的好處-查詢速度加快
  ```
  ModelA.hasOne(models.ModelB)
  ModelA.hasMany(models.ModelB)
  ModelA.belongsTo(models.ModelB)
  ModelA.belongsToMany(models.ModelB)
  ```
> To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define.
[Association](https://sequelize.org/master/class/lib/associations/base.js~Association.html)



## 補充：model.init 設定
1. model.init 是sequelize 是透過初始化設定來產生特定model類別，而特定model類別會繼承於通用model類別，而在這裡的設定會是以通用model類別會有的屬性來初始化，具體會定義：
  - 定義特定model類別下對應的資料表格會有哪些欄位或者屬性
  - 定義特定model類別下的建構式所擁有的屬性和設定
  - 建構式則是用來構成對應資料表格的實例
2. model.init形式會是：
  - attributes是定義對應的資料表格會有哪些欄位或者屬性
  - options是定義對應的建構式所擁有的屬性和設定
```
 init(attributes: object, options: object): Model
```

3. 常見的options值如下：
  - options.modelName: 為字串，定義model的名稱，**用途為：用model類別和model類別實例來操作資料時所要用識別資料**
  > Set name of the model. By default its same as Class name.
  - options.tableNmae： 為字串，定義model所對應的資料表格名稱是為何，預設下若沒設定，會將options.modelName當作options.tableName，**用途為：用model類別和model類別實例來操作資料時所要用識別資料**
  - options.underscored: 為布林值，true代表啟用某功能；false代表不啟用某功能，啟用是指**啟用自動將該model下的屬性名轉換換成snake case命名法的形式**，但除了queryInterface是sequelize直接用SQL與資料庫連接以外，該介面會提供一系列的API，但這些API主要是直接對應著SQL，不像一般model使用方法那樣，還要經由sequelize本身的model來處理，才能轉換成對應SQL與資料庫處理。
  > Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set field option
  - options.freezeTableName：為布林值，true代表啟用某功能；false代表不啟用某功能，啟用是指**強制將取得的model name轉換成複數形式來表示，若不啟用就不轉換**
  > If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized
4. 參考資料
[model.init](https://sequelize.org/master/class/lib/model.js~Model.html#static-method-init)