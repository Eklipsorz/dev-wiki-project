---
sidebar_position: 48
---

# u110 新知和技術 

## 建立使用者登入機制

安裝及設定 Passport

```
npm install passport@0.4.1 passport-local@1.0.0
```

設定 config/passport.js
```
 touch config/passport.js
```


```
const passport = require('passport')
const LocalStrategy = require('passport-local').Strategy
const bcrypt = require('bcryptjs')
const { User } = require('../models')

function usePassport(app) {
  app.use(passport.initialize())
  app.use(passport.session())

  passport.use(new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  }, (req, email, password, done) => {
    User.findOne({ where: { email } })
      .then(user => {
        if (!user) {
          return done(null, false, req.flash('error_messages', '帳號或密碼輸入錯誤！'))
        }
        return bcrypt.compare(password, user.password)
          .then(isMatched => {
            if (!isMatched) {
              return done(null, false, req.flash('error_messages', '帳號或密碼輸入錯誤！'))
            }
            return done(null, user)
          })
      })
      .catch(error => done(error, false))
  }))

  passport.serializeUser((user, done) => {
    done(false, user.id)
  })

  passport.deserializeUser((id, done) => {
    User.findByPk(id)
      .then(user => done(null, user))
  })
}

exports = module.exports = usePassport
```

改良目標為：將config/passport.js更專注於config的層面，主要修改了：
1. 從passport.js移除app載入passport的部分以及所需要的初始化
2. 透過passport的require特性-間接建立了passport物件，來直接在config/passport做後續建立實例後所需要做的設定，所以後頭只需要在app.js執行require('./config/passport')以及在那之後添加passport.initialize()以及passport.session()就行

```
const passport = require('passport')
const LocalStrategy = require('passport-local').Strategy
const bcrypt = require('bcryptjs')
const { User } = require('../models')

passport.use(new LocalStrategy({
  usernameField: 'email',
  passwordField: 'password',
  passReqToCallback: true
}, (req, email, password, done) => {
  User.findOne({ where: { email } })
    .then(user => {
      if (!user) {
        return done(null, false, req.flash('error_messages', '帳號或密碼輸入錯誤！'))
      }
      return bcrypt.compare(password, user.password)
        .then(isMatched => {
          if (!isMatched) {
            return done(null, false, req.flash('error_messages', '帳號或密碼輸入錯誤！'))
          }
          return done(null, user)
        })
    })
    .catch(error => done(error, false))
}))

passport.serializeUser((user, done) => {
  done(false, user.id)
})

passport.deserializeUser((id, done) => {
  User.findByPk(id)
    .then(user => done(null, user))
})

exports = module.exports = passport

```

於app.js設定以下
```
const passport = require('./config/passport')
.
.
.
app.use(passport.initialize())
app.use(passport.session())
```

passport.initialize：初始化 Passport
passport.session：啟動 session 功能，這組設定務必要放在 session() 之後




// done 實作對應為如下，其中info為指定的flash message內容，通常會由done去調用req.flash來設定不同種類的訊息，內容會是info，
```
  function verified(err, user, info) {
    if (err) { return self.error(err); }
    if (!user) { return self.fail(info); }
    self.success(user, info);
  }
```
參考資料為
[What is "done" callback function in Passport Strategy Configure "use" function](https://stackoverflow.com/questions/32153865/what-is-done-callback-function-in-passport-strategy-configure-use-function)


在這裏可以改成直接呼叫req.flash(a, b)來建立訊息種類a的陣列來存放內容b
```
done(null, false, req.flash(a, b))

```




至於最後一段序列化。序列化 (serialization) 是一種轉換資料轉化為可儲存形式的過程 (process)，並且這個形式能夠在需要的時候恢復原先狀態 (反序列化)。下面我們用 Passport 儲存使用者資訊的流程來進一步理解：

passport.serializeUser((user, cb) => {
  cb(null, user.id)
})
passport.deserializeUser((id, cb) => {
  User.findByPk(id).then(user => {
    console.log(user) // 暫時添加
    return cb(null, user)
  })
})
在登入以後，Passport 預設會把整個 user 物件實例都存在 session 裡面，這樣的問題是會佔用許多 session 空間，而且很多資訊我們可能也用不到。

但其實因為 user id 是獨一無二的，只要有 user id，就能夠再另外查找出 user 物件。「序列化」的作法是只存 user id，不存整個 user，而「反序列化」就是透過 user id，把整個 user 物件實例拿出來。

當資料很大包、會頻繁使用資料，但用到的欄位又很少時，就會考慮使用序列化的技巧來節省空間，優點是伺服器記憶體不會耗那麼快，而缺點是這樣一來需要跟資料庫做更頻繁的溝通來拿資料。

總之，這裡 Passport 已經幫我們準備好了序列化和反序列化的實作，把這段程式碼加到 Passport 設定檔裡，以後你就可以呼叫這兩個方法。





實作登入表單頁面

接著要來實作的是登入表單，這一頁和註冊頁非常相似，只有一點點更動，請在 views 底下新增 signin.hbs：
```
$ touch views/signin.hbs
```

並在 signin.hbs 加入以下程式碼：
```
<div class="mb-4 text-center">
  <h1 class="h3 font-weight-normal mb-3">Sign In</h1>
</div>
<form class="form-signin" action="/users/signin" method="POST">
  <div class="form-row mb-3">
    <label class="form-label" for="email">Email</label>
    <input class="form-control" id="email" type="text" name="email" class="form-control" placeholder="Email" required
      autofocus>
  </div>
  <div class="form-row mb-3">
    <label class="form-label" for="password">Password</label>
    <input class="form-control" id="password" type="password" name="password" class="form-control"
      placeholder="Password" required>
  </div>
  <button class="btn btn-primary btn-block" type="submit">Submit</button>
</form>
<div class="mb-4 text-center">
  <p><a href="/users/signup">Sign Up</a></p>
</div>
```


修改 user-controller

```
  signInPage: (req, res) => {
    res.render('signin')
  },
  signIn: (req, res) => {
    req.flash('success_messages', '成功登入！')
    res.redirect('/restaurants')
  },
  signOut: (req, res) => {
    req.flash('success_messages', '登出成功！')
    req.logout()
    res.redirect('/signin')
  }

  ```

  於/modules/user.js設定路由get /users/signin、post /users/signin、get /users/signout

  ```
// 需要載入寫入先前設定的passport實例來執行對應本地端驗證
const passport = require('../../config/passport')

router.get('/signin', userController.signInPage)

router.post('/signin', passport.authenticate('local', {
  failureRedirect: '/users/signin',
  failureFlash: true
}), userController.signIn)

router.get('/signout', userController.signOut)
.
.

exports = module.exports = router

  ```



補充：將 user 物件轉成 JSON 格式

Sequalize 打包後的物件，多包裝了幾層，並且裡面加上一些 Sequalize 內建的參數與方法，讓我們可以直接透過 Sequalize 操作這筆資料，例如刪除或更新 user，不過我們的專案不會用到這些功能，所以就可以運用 toJSON() 這個小技巧來整理格式，把資料簡化變更我們比較容易取用的樣子。


  passport.deserializeUser((id, done) => {
  User.findByPk(id)
    .then(user => done(null, user.toJSON()))
})