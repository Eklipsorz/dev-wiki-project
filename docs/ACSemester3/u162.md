---
sidebar_position: 86
---

# u162的新知和技術


## 依條件切換按鈕

接下來我們希望在頁面上顯示出來的「加到最愛 / 移除最愛」按鈕，可以反應使用者的收藏狀態。頁面包含「餐廳論壇首頁」和「餐廳個別頁面」

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1644407489/blog/deployment/toggle_ok_eb8a7a.gif)

### 初步構想
這個功能最主要的核心，是在瀏覽餐廳頁面時，判斷使用者是否已經收藏了某個特定的餐廳。

以下是我們對這個功能邏輯的初步想像，先把該使用者收藏的餐廳全部撈出來，然後比對特定餐廳是不是已經被登錄在這個列表裡，有的話就代表已經加入我的最愛，沒有的話就代表沒有。

研究完上述邏輯後，我們將實作步驟拆解成三步：

撈出使用者收藏清單
比對清單
依條件切換按鈕



通常include是指示目前modelX與哪個model做left outer join，而指定哪一種model的形式可以是：
  - model 名稱
  ```
  // 指定model2來做left outer join
  include: model2
  ```
  - 包含model屬性的物件，model是指定要哪一個model來做
  ```
  // 指定model2來做left outer join
  include: { 
    model: model2
  }
  ```
  - 包含model屬性和as屬性的物件，model是指定要哪一個model來做，假若前面指定的model與其他model之間存在著關聯並取了別名來表示其關係的話，那麼可以透過model和as來指明要哪一種關聯的model來與目前modelX做left outer join
  ```
  include: {
    model: model2, as: relationshipAlias
  }
  ```
  舉例來說，假設有三種表格分別為使用者、餐廳、收藏清單，其中收藏清單是餐廳本身



```
User.findByPk(id, {
    include: [
      { model: Restaurant, as: 'FavoritedRestaurants' }
    ]
  })
```


```

// ...
passport.serializeUser((user, cb) => {
  cb(null, user.id)
})
passport.deserializeUser((id, cb) => {
  // 修改以下
  return User.findByPk(id, {
    include: [
      { model: Restaurant, as: 'FavoritedRestaurants' }
    ]
  })
    .then(user => {
      user = user.toJSON()
      return cb(null, user)
    })
})
module.exports = passport
```
注意在 include 的時候有追加 as: 'FavoritedRestaurants'，隨著專案變大，User 跟 Restaurant 的關係可能會愈來愈多 (例如，使用者收藏過的餐廳、使用者評論過的餐廳⋯⋯)，如果你沒有加 as 的話，誰知道你要引入的是哪一種？

這時候我們用 as 來標明我們想要引入的關係，而這個 as 會對應到我們剛剛在 model 裡設定的別名：





比對清單 - Controller

接下來要回到 controllers/restaurant-controller.js 中的 restaurantController.getRestaurants，裡面有一大段整理餐廳資料的程序。

還記得我們在上一章節「前台瀏覽餐廳總表」時，有對餐廳的 description 字串做截取，最後輸出給樣板的餐廳資料被放在 data 裡。

比對清單的工作也可以放在一起：

// ...
.then(([restaurants, categories]) => {
  const data = restaurants.rows.map(r => ({
    ...r,
    description: r.description.substring(0, 50),
    isFavorited: req.user && req.user.FavoritedRestaurants.map(fr => fr.id).includes(r.id) //新增這一行
  }))
// ...

判斷哪一家餐廳是否被當前使用者收藏至收藏清單，會在餐廳渲染用的資料那邊添加isFavorited來判別，實際上不會真的添加至資料庫中，具體的isFavorited判別方式為：
  - 每一家餐廳的id都在收藏清單遍歷一遍尋找是否有在清單，若有就表示已被當使用者收藏且顯示移除收藏，若沒有就表示未被使用者收藏且顯示增加收藏，該方法具有效能問題：每一次的id迭代都要重新生成收藏清單然後檢查id在不在清單
  ```
  .then(([restaurants, categories]) => {
  const data = restaurants.rows.map(r => ({
    ...r,
    description: r.description.substring(0, 50),
    isFavorited: req.user && req.user.FavoritedRestaurants.map(fr => fr.id).includes(r.id) //新增這一行
  }))
  ```
  - 修正前者問題，先產生收藏清單，然後再依餐廳id迭代來一個又一個比對清單是否存在餐廳。
  ```
  .then(([restaurants, categories]) => {
  const favoritedRestaurantsId = req.user && req.user.FavoritedRestaurants.map(fr => fr.id) // 新增這一行
  const data = restaurants.rows.map(r => ({
    ...r,
    description: r.description.substring(0, 50),
    isFavorited: favoritedRestaurantsId.includes(r.id) //修改這一行
  }))
  ```

因此後面 Handlebars 在處理資料時，每筆餐廳物件上就有一個 isFavorited 屬性，讓 Handlebars 可以用 if/else 去判斷要渲染哪一個按鈕。

## 補充： association as 和 include as 
model本身對應著表格，表格之間總會有關聯(relation或者association)來對應，同樣的一對一對應關係、一對多對應關係、多對多對應關係會因為應用場景的不同而產生不同的關聯，比如說就拿使用者和餐廳之間是多對多關係的話，可以建構評論關聯：同個使用者可對多個餐廳作出評論，同個餐廳的評論可以由多個使用者來發出，除了評論關聯，還能是喜歡關聯：同個使用者可對多個餐廳作出喜歡，同個餐廳的喜歡可以由多個使用者來做出，從這能發現出同個多對多對應關係會因為場景而演變成評論關聯、喜歡關聯
1. 為了進一步根據場景來快速轉換成特定關聯處理，所以就使用了alias機制來為每個關聯做出命名、取別名，透過別名就能直接沿用對應關聯的設定和定義。

2. 定義 association的別名方式為如下，功能是將modelA和modelB之間的association取上something這個別名，以方便調整適合場景的關聯，
```
modelA.association(modelB, {..., as: 'something'})
```
3. 運用association的方式如下：
  - 運用include的場景，在這裡會依照modelA和modelB之間的關聯設定-something來做left join，若是多對多的話，modelA會跟through表格先做left join而滿足something對應的關聯，隨後再透過合併結果來與modelB做最後的left join，剩餘的細節和一對一、一對多關聯就依據於modelA對於modelB之間的關聯設定

```
// 關聯定義並取名為something
modelA.association(modelB, {..., as: 'something'})
modelA.finder(...{ include { model: modelB, as: 'something' } })
```

  - something對應的關聯由於是指定什麼樣的關聯下，modelA會如何跟modelB做left join，所以對應關聯會是指單方面從modelA至modelB的對應關係

  - 在這裡的modelB在之後的合併結果會以something作為開頭，若沒設定as，就以modelB對應的table名字來標示哪些屬性是源自於modelB
  ```
  // 沒添加as
  'modelB.property1' : value1,
  'modelB.property2' : value2,
  .
  .
  'modelB.propertyN' : value2

  // 添加as後
  'something.property1' : value1,
  'something.property2' : value2,
  .
  .
  ```

4. 案例：假如有三個表格分別為使用者表格、餐廳表格、最愛清單表格，第三個會是為了簡化前兩者間的多對多關係為一對多關係而新增的表格，在這裡會於使用者對應的model檔案定義使用者單方面對於餐廳的關聯是多對多，並設through表格最愛清單表格，而將自己的primary key拿去給餐廳當userId，最後將這個關聯設定取一個FavoritedRestaurants的別名，以方便切換不同的關聯模式，接著在實際使用這個關聯設定的時候，就在使用者對應餐廳之間的關係來使用，比如User.findByPk(id, { include: { model restaurant, as:xxx}})中的as就是採用FavoritedRestaurants來做User和Restaurant之間的關聯。

  ```
  // 定義使用者對於餐廳的關聯設定並取名為FavoritedRestaurants
    User.belongsToMany(models.Restaurant, {
        through: models.Favorite,
        foreignKey: 'userId',
        as: 'FavoritedRestaurants'
     })
  // User model在滿足FavoritedRestaurants指定的關聯下與Restaurant model做left join
    return User.findByPk(id, {
      include: [
        { model: Restaurant, as: 'FavoritedRestaurants' }
      ]
    })
  ```