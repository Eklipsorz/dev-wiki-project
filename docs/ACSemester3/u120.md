---
sidebar_position: 57
---

# u119 新知和技術  


## 上傳餐廳照片 - multer 
在這裡為了讓每個餐廳都擁有各自的圖片檔案並顯示在網頁上，所以在資料庫上的設計會增加一個欄位來儲存圖片檔案，而圖片檔案可由管理員從本地端上傳至伺服器，當上傳至伺服器時，伺服器會指定放在特定目錄並以其檔案路徑來代表它，同時間也以其路徑作為每家餐廳的新欄位值-img，最後再透過其路徑和img元件來顯示，這裡主要會做以下事情：
  - 替餐廳增加一個名為image欄位，該欄位型別為字串
  - 安裝multer套件
  - 替每個與餐廳資料變更的表單增加一個元件來允許使用者上傳圖片
  - 


### 替餐廳增加一個名為image欄位，該欄位型別為字串

新增一個migration檔案名為add-image-to-restaurants
```
npx sequelize migration:generate --name add-image-to-restaurants
```

定義該migration檔案具體要做的migration是什麼
```
'use strict'

module.exports = {
  up: async (queryInterface, Sequelize) => {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
    await queryInterface.addColumn('Restaurants', 'image', {
      type: Sequelize.STRING
    })
  },

  down: async (queryInterface, Sequelize) => {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
    await queryInterface.removeColumn('Restaurants', 'image')
  }
}
```

執行該migration 檔案來新增欄位
```
npx sequelize db:migrate
```

替Restaurant model增加其欄位
```
Restaurant.init({
    name: DataTypes.STRING,
    tel: DataTypes.STRING,
    openingHours: DataTypes.STRING,
    description: DataTypes.TEXT,
    address: DataTypes.STRING,
    image: DataTypes.STRING
  }, {
    sequelize,
    modelName: 'Restaurant',
    tableName: 'Restaurants',
    underscored: true
  })
```



### 安裝 multer
1. multer 是第三方套件，主要提供一個middleware能夠處理multpart/form-data形式的資料，而該形式的資料通常都會用作上傳檔案
> Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency.

安裝方式：
```
 npm install multer
```



### 替每個與餐廳資料變更的表單增加一個元件來允許使用者上傳圖片
加入圖片上傳區，只要到 views/partials/admin-restaurant-form.hbs 裡，在表單最底部新增一個上傳圖片的元件

```
<div class="form-row mb-3">
  <label class="form-label" for="image">Image</label>
  <input class="form-control" type="file" class="form-control-file" id="image" name="image">
</div>
```


顯示圖片
下一步是修改前端的 view，讓圖片順利顯示出來。讓我們到餐廳的顯示頁面裡，加上顯示圖片的區塊。

打開 views/admin/restaurant.hbs：

```
// ...
  <div class="col-md-4">
// 新增以下
    <img class="img-responsive center-block" src="{{restaurant.image}}" style="width: 250px; margin-bottom: 25px; transition: opacity 0.5s; opacity:0;" onload="this.style.opacity=1;">
    <br>
```

設定 Content-Type

MDN 裡面有提到，如果表單包含如下，像是我們現在要用表單寫入圖片，會需要特地把格式改成 multipart/form-data，才能順利地把圖片一起 POST 進去。
```
<input type="file"> ，
```
那透過 表單 來設定 Content-Type 的時候，會使用的屬性名稱是 enctype ，現在讓我們把這個屬性加進去，請你打開 views/admin/create-restaurant.hbs：

```
<form action="/admin/restaurants" method="POST" enctype="multipart/form-data"> // 修改這
```
一行
同時 views/admin/edit-restaurant.hbs 也要做一樣的設定：

```
<form action="/admin/restaurants/{{restaurant.id}}?_method=PUT" method="POST" enctype="multipart/form-data"> // 修改這一行
```

## 補充：file類型的input
1. 可允許使用者輸入單一檔案(圖片)為內容的元件，但一次只能輸入一個檔案，形式為
```
<input type="file">
```
2. 若將該元件放至表單中，而當表單提交時，就會將圖片編碼成特定形式傳送給伺服器處理
```
<form>
  <input type="file">
</form>
```

## 補充：content-type
1. 設定傳輸內容是以何種形式編碼來傳遞：傳統上會是以同一形式來編碼，要嘛內容全都以文字形式來編碼傳遞，要嘛內容全都以檔案形式來編碼傳遞，而為了進行綜合這兩種形式的編碼，而增加了multipart類型。
  - 文字形式：text/html(HTML檔案)、text/plain(純文字)、application/json(JSON檔案)
  - 檔案形式：application/pdf(pdf檔案)、video/mpeg4(影片檔)
  - 綜合文字和檔案形式：multipart/form-data(用於表單資料傳遞)
2. 若表單採用於multipart/form-data的話，當表單發生提交時，可將表單內含的圖片和文字分別以各自形式來編碼並傳遞至伺服器或者目的地，其中enctype是指定發生提交傳遞時以何種形式編碼傳遞。
```
<form enctype="multipart/form-data">
  <input type="file"....>
  <input type="text">
</form>
```

## 補充：顯示圖片元件
1. 首先會將上傳的圖片放置特定目錄，並以該圖片的所在路徑來代表它，同時也可以將路徑來儲存在資料庫
2. 若要顯示圖片的話，可以使用其路徑和img元件來顯示
```
<img src={{ restaurant.img }}>
```


### 實務上開發：
1. 若樣式要放在渲染檔案中的話，可以是:
  - inline style：
  ```
  <img style="width: 250px; margin-bottom: 25px; transition: opacity 0.5s; opacity:0;" onload="this.style.opacity=1;">
  ```
  - 以獨立樣式檔案來給予渲染檔案引用






觀念：temp 資料夾 vs upload 資料夾

由於要上傳圖片，我們需要在專案裡準備一個資料夾來儲存圖片。建議的設置如下：

表單透過 multer 上傳檔案時，一律先傳到 temp 資料夾
確定成功上傳檔案，才把檔案完整的檔案複製一份到 upload 資料夾
刻意把「上傳檔案的資料夾 temp」和「使用檔案的資料夾 upload」分開，有以下考量：

把上傳跟使用的邏輯分開，成功上傳才對外開放存取
檔案在傳輸的時候，一張圖片會被分成好幾個碎片分批上傳，但上傳 的過程有可能發生意外，例如網路連線中斷、或是使用者突然關掉網頁等等，「上傳失敗」的暫存檔案會留在 temp 資料夾裡，需要定時清空該資料夾，但 upload 資料夾裡必定是完整的檔案
可以順便自定義檔名 (基礎的 multer 沒有自定義檔名的功能)



新增 middleware

剛提到 multer 它可以包裝成一個 middleware，那我們就先在 middleware 資料夾下建立一個 multer.js：
```
$ touch middleware/multer.js
```

裡面蠻簡單的：
```
// 載入Multer的建構式
const multer = require('multer')

// 使用Multer建構式來建立Multer實例，並設定上傳地點為temp
const upload = multer({ dest: 'temp/' })

// 將設定過的Multer實例匯出去
module.exports = upload
```



更新路由

首先，請思考一下上傳圖片這個動作會出現在哪些情境？

依照目前有的功能，應該是「新增一家餐廳 (put)」和「編輯餐廳 (post)」這兩種情境。因此，這兩個情境對應的路由和 controller 需要修改。

controller 比較複雜，先來 routes/modules/admin.js 這邊改路由。我們要先把 multer 載進來，然後在會用到上傳圖片的路由，加上 multer 這個 middleware，我們用 upload.single('image') 來表示單張圖片的上傳：


// upload.single('image') :會先block後頭的middleware，等到上傳完成之後才執行後頭的middleware
// multer 會額外生成worker thread去做上傳檔案的工作，等到完成的時候就會通知主執行緒處理後續

```
router.post('/restaurants', upload.single('image'), adminController.postRestaurant) // 修改後台新增餐廳的路由
```



```
// ...
const adminController = require('../../controllers/admin-controller')
const upload = require('../../middleware/multer') // 載入 multer
router.get('/restaurants/create', adminController.createRestaurant)
router.get('/restaurants/:id/edit', adminController.editRestaurant)
router.get('/restaurants/:id', adminController.getRestaurant)
router.put('/restaurants/:id', upload.single('image'), adminController.putRestaurant) // 修改後台編輯餐廳的路由
router.delete('/restaurants/:id', adminController.deleteRestaurant)
router.get('/restaurants', adminController.getRestaurants)

// upload.single('image') 會先block後頭的middleware，等到上傳完成之後才執行後頭的middleware
router.post('/restaurants', upload.single('image'), adminController.postRestaurant) // 修改後台新增餐廳的路由
router.get('', (req, res) => res.redirect('/admin/restaurants'))

```



修改 controller 以前，我們要來做一個專門處理檔案的 helper。
```
 $ touch helpers/file-helpers.js
 ```
這支檔案會用到 fs 模組。fs 模組是 Node.js 提供專門來處理檔案的原生模組，因此你不需要額外安裝，即可引入使用。 fs 是 File system 的縮寫，以下的邏輯主要是從官方文件說明中，查找到取出檔案的方法，再組合而成：
```
const fs = require('fs') // 引入 fs 模組
const localFileHandler = file => { // file 是 multer 處理完的檔案
  return new Promise((resolve, reject) => {
    // 若檔案不存在，就不處理
    if (!file) return resolve(null) 
    // 檔案存在處理
    // 接著將未來位置和檔案名稱定義好
    const fileName = `upload/${file.originalname}`
    // 以promise形式來讀取檔案內容
    return fs.promises.readFile(file.path)
      // 讀取完並以data寫入至未來預定的檔案內
      .then(data => fs.promises.writeFile(fileName, data))
      // 若順利寫入，就回報
      .then(() => resolve(`/${fileName}`))
      .catch(err => reject(err))
  })
}
module.exports = {
  localFileHandler
}
```
解釋一下 localFileHandler 內的邏輯：

傳入的 file 是 multer 處理完的檔案。等等我們會在 controller 裡面處理。如果檔案不存在，直接結束這個函式，後面不會執行了。
保存原始檔案名稱，前面接上字串 upload，並存在 fileName 變數中。upload 就是到時候我們要拿來對外的資料夾名稱。
把檔案複製一份到 upload 資料夾底下。
至於為什麼要命名 localFileHandler 呢？ local 指的是本地伺服器。現在是開發階段，把圖片存在本地伺服器是 ok 的，不過假設未來使用者變多，我們很可能就不會在本地伺服器端去處理圖片，而是考慮其他雲端服務，這部分先留個伏筆，之後會再帶大家調整。

另外，如果你之後有餘力想自己深究每個方法的來源與用法，可以給你一個方向分辨：

file 開頭的，是 multer 提供的方法，例如 file.originalname 、 file.path ，可查 multer 文件
fs 開頭的，是 fs 提供的方法，例如 fs.promises.readFile 、fs.promises.writeFile，可查 Node.js 中的 File system文件
其他都是 JavaScript 原生語法，可查 MDN


修改 controller


postRestaurant ：
```
const { Restaurant } = require('../models')
const { localFileHandler } = require('../helpers/file-helpers') // 將 file-helper 載進來
// ... 
 },
  postRestaurant: (req, res, next) => {
    const { name, tel, address, openingHours, description } = req.body
    if (!name) throw new Error('Restaurant name is required!')
    // multer 將上傳完畢的檔案資訊放入req.file
    const { file } = req 
    
    // 將檔案資訊交給localFileHandler，並委託他把檔案複製至upload目錄下
    // 若有回傳檔案路徑，代表已複製成功
    // 若回傳NULL，就代表沒任何複製行為
    localFileHandler(file) 
      .then(filePath => Restaurant.create({ 
        name,
        tel,
        address,
        openingHours,
        description,
        // 若filePath 為null 就代表沒上傳圖片
        image: filePath || null
      }))
      .then(() => {
        req.flash('success_messages', 'restaurant was successfully created')
        res.redirect('/admin/restaurants')
      })
      .catch(err => next(err))
  },
// ...
```

image: filePath || null 的意思是：如果 filePath 的值為檔案路徑字串 (使用者有上傳檔案，就會被判斷為 Truthy)，就將 image 的值設為檔案路徑；如果 filePath 的值是空的 (也就是沒有上傳檔案，因此沒有檔案路徑，會被判斷為 Fasly)，那麼就將 image 的值設為 null。



```
putRestaurant: (req, res, next) => {
    const id = req.params.id
    const { name, tel, address, openingHours, description } = req.body
    const { file } = req
    Promise.all([
      Restaurant.findByPk(id),
      localFileHandler(file)
    ])
      .then(([restaurant, filePath]) =>
        restaurant.update({
          name,
          tel,
          address,
          openingHours,
          description,
          image: filePath || restaurant.image
        })
      )
      .then(() => {
        req.flash('success_messages', 'restaurant was successfully to update')
        res.redirect('/admin/restaurants')
      })
      .catch(error => next(error))
  },

```


設定靜態檔案路徑 /upload

開好資料夾以後，還需要設定路由，讓外部傳入的 request 可以取得 /upload 這個路徑。

這裡因為是靜態檔案，所以不需要像其他的路由一樣寫 controller 邏輯，直接用 express.static 來指定路徑就可以了，請到 app.js 中修改如下：


```
const express = require('express')

const path = require('path')

app.use('/upload', express.static(path.join(__dirname, 'upload')))

app.listen(port, () => {
  console.info(`Example app listening on port ${port}!`)
})

module.exports = app
```


## 補充：multer 
1. multer 是第三方套件，主要提供一組middleware能夠處理multpart/form-data形式的資料，而該形式的資料通常都會用作上傳檔案或者以表單的形式提交給伺服器
> Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency.

2. multer本身是生成一組middleware的套件，當要載入其套件時，會拿到multer middleware的建構式-multer，在這裏必須利用其建構式來定義一個multer middleware實例以及檔案上傳檔案地點在哪-dest
```
// 載入Multer的建構式
const multer = require('multer')

// 使用Multer建構式來建立Multer實例，並設定上傳地點為temp
const upload = multer({ dest: 'temp/' })
```
3. 當multer middleware 實例所生成的middleware 安插至某個請求下的middleware stack時，系統會每當執行到multer middleware 會做以下事情：
    - 是否有multipart/form-data形式的封包
    - multipart/form-data形式的封包內是否有檔案，沒的話就交由下一個middleware 執行
    - 有的話，系統就生成一個執行緒去負責將檔案傳遞至目的地-dest，在這過程中，並不會交由下一個middleware執行，直到該執行緒傳遞完畢之後，該multer middleware就將傳遞結果寫入至req物件，最後將控制權轉交給下一個middleware執行

4. multer所能提供的middleware有：
  - multer.single(fieldname)：該函式會回傳一個middleware，該middleware會檢查每個經過的封包是否有multipart/form-data的表單以及表單內是否有fieldname這個欄位、檢查是否為檔案，進行上傳等等，如同上面那樣，在這裏single是強調著該函式的middleware只能一次上傳單個檔案


4. 案例：系統接收到POST PATH請求時，會先執行middleware1，接著執行完該middleware，就執行multer的single middleware，若檢查到請求封包內有multipart/form-data的表單且表單內有image這欄位，就會檢查是否有檔案，若沒有的話，就會結束single middleware，讓middleware2和middleware3接著執行，但若有的話，系統會先為該single middleware生成一個執行緒去處理檔案上傳的部分，上傳過程中，會阻檔middleware2和middleware3執行，直到執行緒處理完上傳的部分並通知single middleware，該middleware就會把檔案資訊寫入至req物件，最後結束single並執行middleware2和middleware3
```
const upload = multer({ dest: 'temp/' })
router.post(path, middleware1, upload.single(image), middleware2, middelware3)
```

