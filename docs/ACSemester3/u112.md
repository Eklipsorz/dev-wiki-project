---
sidebar_position: 50
---

# u112 新知和技術 

## 驗證登入狀態與後台權限

### 確認「身份驗證」是什麼
由於登入者分為一般使用者和管理員，所以有部分頁面是只有一般使用者能存取的，也有一部分頁面是只有管理員看到的，在這裏使用isAdmin和is_admin來判別哪個使用者是管理員

首先先確認一下「身份驗證」到底發生在什麼地方，這個動作應該是要發生在頁面讀取出來之前。而我們的網站要求「要看任何頁面都需要先登入」，至於後台則是「只有管理員才能看到後台頁面」。
我們可以在 users 資料表上加開一個欄位 is_admin，然後用 true/false 來判斷是否為管理員 (在 MySQL 裡面 1 表示 true、0 表示 false)：
### 在 Users table 新增 is_Admin 的欄位
實作is_Admin增加的欄位

因此，等下我們的實作步驟如下：

在 Users table 新增 is_Admin 的欄位
在路由加入檢查身份的 middleware
```
npx sequelize migration:generate --name add-is-admin-to-users
```
學期會引導各位同學實作比上學期複雜的專案，在構思功能時，可能無法一口氣把資料結構都想清楚，所以一定會需要在中途用 migration 修改資料庫，之前有提過 migration 是資料庫的版本控制，我們現在是「把 is_admin 欄位加到 Users table」，所以取名就是 add-is-admin-to-users。

有同學可能會好奇為什麼不取 add-isAdmin-to-users 或者 add-is_admin-to-users，其實都可以，只是教案希望統一用烤肉串式命名法來處理本專案的檔名。

執行成功以後，這時 migration 資料夾下就會產生一支 xxxxx-add-is-admin-to-users.js請你打開這個檔案，看一下裡面的內容 (記得呼叫 Eslint 把分號去掉)：
Sequelize 很貼心地用註解寫好了一些範例，那我們這邊要在 up 動作裡定義要新增欄位，然後在 down 動作裡定義回退時要刪掉的欄位：
```
'use strict'
module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('Users', 'is_admin', {
      type: Sequelize.BOOLEAN,
      defaultValue: false
    })
  },
  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'is_admin')
  }
}
```

在 up 裡面，我們幫 Users 新增了一個叫做 is_admin 的欄位，型態是 Boolean，預設值是 false，在 down 裡面則把這個欄位刪除。語法細節可以參考下一段拆解，講師其實就是查了 Sequelize 文件中能夠直接跟資料庫溝通的方法，然後照著文件說明寫進來。

補充：為什麼要寫 is_admin

在 up 這裡，新增欄位的程式碼中，我們特別寫 snake_case 的 is_admin。你可能會覺得很疑惑，我們在創建 User Model 的時候，不是已經加上副指令 --underscored，設定創建出來的欄位名稱會自動轉成 sanke case 了嗎？為什麼這裡還要自己留意呢？

這是因為這我們用了 Sequelize 提供的方法 queryInterface.addColumn() 直接來操作資料庫：

第一個參數是要操作的資料表 (table)：需要一個字串來指定，這裡我們給 Users
第二個參數是要新增的欄位名稱 （column name)：需要一個字串來指定欄位，這裡我們給 is_admin
第三個參數是定義這個欄位的屬性 (attribute)：需要一個物件來設定，這裡我們寫 { type: Sequelize.BOOLEAN, defaultValue: false } ，指定資料型態是布林值、預設情況是 false
第四個參數不是必須的，可以根據的需求來加更多設定選項，例如官網範例是設定 after: 'columnB' ，指定了現在新增的這個欄位要排在 columnB 後面。


**由於前者只是migration，並為真實改變對應model的屬性，所以若要有完整性的驗證功能，必須自行添加對應的屬性isAdmin**


確認資料庫裡面多了一個欄位之後，就可以把這個欄位同步到 Model 裡。請打開 models/user.js，在欄位清單裡加入 isAdmin 這個屬性：
```
  User.init({
    name: DataTypes.STRING,
    email: DataTypes.STRING,
    password: DataTypes.STRING,  // 補逗點
    isAdmin: DataTypes.BOOLEAN   // 加入這行
  }....(後略)
```
注意到這裡寫小駝峰式 isAdmin 就可以了，因為這邊是純 JavaScript 實作，先前的 --underscored 副指令會在操作資料庫的時候，幫我們把 JavaScript 這邊的命名自動轉成 snake case 的欄位名稱 is_admin。

現在資料庫跟 User Model 都有了 isAdmin 的欄位了。

### 在路由加入檢查身份的 middleware
**在這裏我們讓管理員和一般使用者都用同一個頁面來登入，但登入後能夠看到的畫面會根據isAdmin來決定，所以在路由清單的安排上，會替一般使用者的登入畫面添增middleware來驗證登入，而管理員本身路由會由另一個middleware來驗證並同時阻擋一般使用者鑽漏洞變成管理員身份的使用者**


新增 ensureAuthenticated

還記得我們剛才開了一支檔案 `auth-helpers.js` 專門來幫我們處理各種和使用者身份驗證相關的事情。現在我們要利用 Passport 提供的 isAuthenticated()：
```
const getUser = req => {
  return req.user || null
}
// 新增這裡
const ensureAuthenticated = req => {
  return req.isAuthenticated()
}
module.exports = {
  getUser,
  ensureAuthenticated // 新增這裡
}
```
新增 auth.js

接著在 middleware 資料夾下新增一隻檔案 auth.js：
```
$ touch middleware/auth.js
```
新增以下程式碼：
```
const { ensureAuthenticated, getUser } = require('../helpers/auth-helpers')
const authenticated = (req, res, next) => {
  // if (req.isAuthenticated)
  if (ensureAuthenticated(req)) {
    return next()
  }
  res.redirect('/signin')
}
const authenticatedAdmin = (req, res, next) => {
  // if (req.isAuthenticated)
  // 檢查使用者是否登入
  if (ensureAuthenticated(req)) {
    // 檢查登入者是管理員
    if (getUser(req).isAdmin) return next()
    // 登入者不是管理員
    res.redirect('/')
  } else {
    // 沒登入成功
    res.redirect('/users/signin')
  }
}
module.exports = {
  authenticated,
  authenticatedAdmin
}

```



一般使用者的路由清單為
```
const express = require('express')
const router = express.Router()
const admin = require('./modules/admin')
const user = require('./modules/user')
const { authenticated } = require('../middleware/auth')
const { generalErrorHandler } = require('../middleware/error-handler')
const restaurantController = require('../controllers/restaurant-controller')

router.use('/admin', admin)
router.use('/users', user)
router.get('/restaurants', authenticated, restaurantController.getRestaurants)
router.use('/', (req, res) => res.redirect('/restaurants'))
router.use('/', generalErrorHandler)

module.exports = router

```
管理員的路由清單為
```
const express = require('express')
const router = express.Router()
const { authenticatedAdmin } = require('../../middleware/auth')
const adminController = require('../../controllers/admin-controller')

router.get('/restaurants', authenticatedAdmin, adminController.getRestaurants)
router.get('/', (req, res) => res.redirect('/admin/restaurants'))

exports = module.exports = router
```

## 認證(Authentication) vs. 授權(Authorization)
1. Authentication：證明某項人事物是真實、正確的、是如同預期般的過程
2. Authorization：授與某項人事物權利去做某件事情的過程
