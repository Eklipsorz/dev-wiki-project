---
sidebar_position: 2
---

# U24 知識&技術

## HTTP 特點
1. 支持客戶/伺服器模式 
2. 簡單快速
3. 靈活
4. 無連接
5. 無狀態


## 連線(Connection)
1. 原文為如下，中文意思為連線在TCP中是種資訊，它包含了socket資訊、序列號(sequence number)、窗口大小(window sizes)，socket資訊包含了主機本身的IP和Port
>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.
2. 起源於
 - [what is connection](https://datatracker.ietf.org/doc/html/rfc793)
 - [为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake/)


 ## 網路插座(Socket)
 1. 原文是指某種裝置的插槽，作用是用來與其他裝置相互連接並傳遞/接收訊號
 2. 在電腦科學裡，會是指電腦網路中的網路節點所具有的軟體結構，其結構會如同字面上的意思而是個插槽，並允許其他裝置透過插槽連接來相互傳遞/接收訊息，插槽間會有實體線路或者無線信號當做媒介來傳輸彼此間的資訊。
 3. 每台電腦都代表著網路節點，換言之，這些電腦上具有一些由軟體建立出來的插槽，插槽之間會透過實體線/無線信號來相互連接，而虛構出來的插槽裝置會負責從中接收和傳送資料
 4. 由於插槽實際上實現是主機之間的網路連接，而主機本身也允許提供額外的應用層的服務，只是若放在同一個插槽勢必多耗成本來檢查每一個接收進來的封包，為此每個服務都會有各自的網路插槽來與其他裝置來連接，以此辨明封包上的種類，並且每個封包按照服務種類來往特定插槽來處理
 5. 由於前者，每個虛構出來的網路插槽都具有port和ip來綁定以此辨明插槽是屬於哪個主機以及主機上哪個服務上。


## 無連線(Connectionless)
1. Connection 指伺服器和客戶端之間在正式傳輸之前所建立的網路連線(三向交握的產物)，而less則是表示著前者在某方面來說的程度或者數量較少，甚至到缺乏的程度或者沒有，兩者結合在一起就是無連線，但並不表示這就不存在著連線，而是連線在某種程度上來說算少的，或者在某種程度來說算沒有，而某種程度在這裡會是指連線持續時間，所以連線持續時間較短的連線或者連線持續時間沒有的連線都稱作為無連線。

2. HTTP的無連線是指連線持續時間較短的連線，每一次連接都只處理一個請求，當伺服器處理完一個客戶請求並回傳結果給客戶端，接著等客戶端回應它已收到回應的訊息給伺服器或者不等，此時伺服器和客戶端就相互刪除代表連線的資訊以此來中斷連線，使連線成為連線持續較短的連線

3. HTTP的無連線是出自於早期向伺服器發送的請求都因為索取的資料較小而具有間歇性(不連續發送同個連線的請求，會隔一段時間發送)且請求量有可能會是巨大的，在巨大的請求量中，由於請求們都因為間歇性而發散，使得連續數量的請求都沒什麼特定關係(如同一個連線)，為了讓伺服器能夠服務更多的請求，所以才以連線持續時間較短的連線來解決。

4. 但隨著時間的推移，每一個請求不再只是索求大小較小的資源，而是會因為所要的資源太大，而必須將請求或者回應分割好幾份小請求或小回應來發送或者回應，然而每當小回應回傳客戶端時，可能會因為無連線的規則而斷開連線，但由於請求/回應還未完全做完，所以又會為了發送請求或者接收回應而再次讓客戶端和伺服器建立連線，並重新接收，然後回應完又斷開，然後再繼續建立連線的迴圈，讓連線建立的成本逐漸成了累贅，甚至進而使得在巨大的請求量中，連續請求會出現較多為同一個連線的情況

5. 為了解決這問題，所以提出了Keep-Alive機制在HTTP的實作上，來讓連線的持續時間延長至伺服器或者客戶端本身認為傳送/接收過程已經結束才停止連線，換言之，由他們決定何時中鍛鍊線，在Keep-Alive的情況下，每個請求所建立的連線會延長，這可以盡可能緩解原本需要一直重複建立連線的傳送/回應的過程，但由於連線延長，所以容易讓連線本身佔據著系統資源。

6. 這裡的無連線通常形容著網路協議(Protocol)，也就是無連線協議，而無連線協議只是不會維持連線時間較長的連線，也並非沒能力提供連線時間較長的連線。

## 無狀態(stateless)
1. State 是指客戶端與伺服器進行請求/回應的cycle時所擁有的狀態，而狀態會是伺服器和客戶端在連線時所發生的過程，而less則是強調前者在某方面的程度或者數量較少，甚至至缺乏的狀態或者沒有，結合在一起就是無狀態，但並表示連線時的狀態就不存在，而是儲存狀況在某種程度來說算少的，或者在某種程度來說算沒有，而這裡的某種程度就是強調著伺服器和客戶端僅限於請求/回應的cycle之狀態下暫時儲存彼此狀態，當結束連線狀態時，兩者並不會永久儲存先前的狀態或者刪掉暫存的狀態。

2. 雖然無狀態強調著盡可能降低伺服器端的儲存成本，但實際上，這特性會阻礙著一些需要前幾次互動狀態的服務，如簡單的購物車程序也要知道用戶到底在之前選擇了什麼商品，為了在不修改無狀態的前提下，來改善問題，有人就提出cookie和session這兩個機制，由客戶端和伺服器本身提供空間來儲存每次互動時的狀態。

3. 這裡的無狀態通常形容著網路協議(Protocol)，也就是無狀態協議，而無狀態協議只是不主動記住狀態資訊，並非沒能力提供儲存狀態的服務

## 無連線和無狀態
1. 參考資料:
  - [HTTP - Overview](https://www.tutorialspoint.com/http/http_overview.htm)
  - [如何理解HTTP協議的 「無連接，無狀態」 特點？](https://kknews.cc/code/9nxbmj8.html)


## HTTP無狀態協議的特點
1. HTTP無狀態協議的特點：
  - HTTP在每個連線互動後就不存互動過程的狀態
  - 在前者的背景之下，由於伺服器沒存過去請求時的狀態，所以每個請求就會像是第一次被伺服器處理的請求，都是獨一獨二的請求
  - 伺服器不知道哪些請求是來自於先前發送/處理過的客戶端


## cookie
1. 由網景公司提出的解法，允許瀏覽器去將每一次連線互動時的狀態存在一個名為cookie的空間或者檔案，接著每一次瀏覽器會利用cookie來對著過去連線過的伺服器發送特定的請求，並讓伺服器以該內容來處理並回應特定的結果
2. 通常會儲存過去客戶端對於伺服器所要求的內容或者獲取內容，比如輸入帳密等，儲存過程中會加密。
3. Cookie 可自由讓使用者或者瀏覽器來決定其內容的去留

## session
1. 原意為為從事某項活動的互動或者從事某項活動的會議，在這裡會將活動設定為每一次伺服器和客戶端之間的連線活動，而會議/互動則本身引申為代表兩者間在連線時的互動紀錄，前兩者合再一起就是伺服器和客戶端之間的連線活動時紀錄。
2. 其紀錄由伺服器端進行，可儲存客戶端和伺服器連線時的互動狀態
3. 由於伺服器本身會處理大量的請求，也意味著有大量的Session儲存在伺服器，所以為了提供穩定的服務，會替每個session安排超時時間，當session紀錄到達時間時，就從伺服器釋放
4. session store 是伺服器存放session 資料的地方，通常會是伺服器的記憶體、某個資料庫服務(如redis)


## cookie 和 session 之間的應用
1. 應用於伺服器和客戶端之間的憑證系統，主要分為：
  - Cookie-based Authentication ：由客戶端提供的cookie內容來認證其對象在伺服器是否為合法對象
  - Token-based authentication：由客戶端發送的請求封包裡夾雜著憑證文字(token)來讓伺服器判斷該請求是否為合法對象。
2. Cookie-based Authentication : 由於cookie是存放客戶端和伺服器端的連線互動時的狀態，很容易被其他電腦獲取其cookie，通常會在cookie內容上加密或者不在cookie儲存敏感性資料，取而代之的是，伺服器本身會以類似的陣列形式來儲存敏感性資料，而cookie就儲存其資料在陣列上的位置，而當伺服器收到請求後，會從cookie取得對應server的session id(在session陣列上的位置)，並透過其id來在伺服器內部存取對應的session內容，最後從內容獲取資料庫的內容。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639747105/blog/http/cookie_session_tgjczs.png)

## 使用者登入認證機制
1. 當使用者進入一個需要帳號密碼來進行登入的頁面時，輸入完帳密並正確導入對應頁面，可如果使用者將頁面關掉，其服務會因為無狀態的關係而沒把帳號密碼的相關狀態存下，而當使用者在進入相同頁面時，使用者會被要求輸入帳密做後續的認證


2. 為了讓使用者更方便登入服務，每當使用者向伺服器成功登入服務時，伺服器就給予使用者一個憑證，讓它能夠在關閉頁面情況下還是能夠依據著憑證直接使用相同服務，不必重新登入
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639985704/blog/loginSystem/Certificate_System_hc5u2n.png)

3. 憑證認證機制具體實現，有四個步驟：在這裡先假設是第一次登入，
  - Step1. 使用者輸入帳密並發送POST /users/login 請求伺服器認證帳密
  - Step2. 伺服器確認帳密是否正確，若正確就建立session來儲存對應帳號的主要屬性並給予session id至客戶端，讓客戶端以cookie儲存
  - Step3. 客戶端收到session id後，就便儲存在cookie中，並且每次對同一個伺服器發送請求時都會讓伺服器去存取cookie內容
  - Step4. 伺服器會去檢查cookie內容的session id是否存在於伺服器中，若存在，就讓客戶端去存取對應的帳號資料
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639932196/blog/loginSystem/implementationOfCertificating_gvmhfx.png)

4. 憑證認證上的安全性：由於是利用儲存在cookie上的session id來做認證，而瀏覽器本身可允許修改cookie內容，因此很容易讓人透過修改session id來偽裝其他人的身份，比如說客戶端原本拿到session-id為a的資料，對應到伺服器的使用者資料就是id為1的使用者，若把session-id更改為b，就可以讓伺服器誤以為是id為2的使用者，讓客戶端直接使用該使用者的資源。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639933781/blog/loginSystem/CertificationStore_a7t3ou.png)



## 憑證認證上的安全性
1. 由於客戶端的cookie很容易被篡改或者惡意修改成其他資料，讓伺服器對應不合法的資源，為了避免這樣，伺服器當發憑證給客戶端時，也就是下圖中的Step2，伺服器會用一個私鑰(private key)和session id產生一組亂碼，而這樣過程被稱之為簽名(sign)，而亂碼本身就是signature，最後會將session id和亂碼合併成一個字串給客戶端讓它做認證，另外其亂碼會存在伺服器中。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639932196/blog/loginSystem/implementationOfCertificating_gvmhfx.png)

合併成的字串格式可能會是：以.為區隔，前半段是session id，後半段為簽名後的亂碼
```
s%3Ax6O_y8GbzQZ83IhRCNiX9Qt-VeeHAlwl.EC9XKGB72koXfNeergC8uPKSO9L19Te%2FN1yrgjYiwJE
```

2. 當客戶端從cookie中拿著session id和亂碼組成的合併字串來向同一個伺服器發出請求時，伺服器會做一系列檢查，比如：
  - 檢查亂碼是否存在session store中，若有的話，就繼續做下一步，沒有就要求對方輸入帳密
  - 其session id和伺服器的私鑰(private key)用同個方法來產生亂數，並且比對該亂數是否和cookie內的亂數一致，若一致就允許使用服務，若不一致就要求對輸入帳密
  - 正常使用服務



  ## Set-Cookie 標頭
  1. 是伺服器回應給客戶端請求的回應封包所含有的標頭，其標頭會要求客戶端建立一個cookie去儲存標頭內的內容。


  ## Cookie 標頭
  1. 是客戶端向伺服器端發送請求的封包所含有的標頭，其標頭內容會是之前客戶端被要求儲存cookie的內容，該內容會被伺服器做認證並做後續處理

  