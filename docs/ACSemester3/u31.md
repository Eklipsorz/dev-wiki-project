---
sidebar_position: 8
---

# U31 知識&技術



## mongoose schema的path
1. mongoose schema下的每個欄位皆為path，而這些欄位名稱和欄位值分別為key和value，欄位名稱描述著某個data model下的每一筆資料會有的屬性，而欄位值則是用物件來定義/設定這些屬性在資料上會有的表現、功能、樣子。
```
new Schema({
  key1: value1, 
  key2: value2,
  .
  .
  .
})
```

2. 欄位值會用名為SchemaType類別下的實例，該類別是主要設定/定義這些屬性在資料上會有的表現、功能、樣子，其中該類別被mongoose.Types以及其他類別所繼承到，一般來說，若使用方法1來定義type屬性值，那麼key1所在的path會是另一個繼承SchemaType的子類別下的實例，而若改使用方法2來定義type屬性值，那麼key1所在的path會是SchemaType類別下的實例，前者和後者的差別在於前者能支援的功能是較簡易，後者能支援較為複雜的操作或者較為完整的操作

```
// way 1
new Schema({
  key1: { type: String }
})

// way 2
new Schema({
  key1: { type: Schema.Types.String }
})
```

## Populate 
1. mongoose的功能之一，主要會從其他集合中的文件來按照指定屬性/path來替代其值，當Schema.Types實例出現著ref屬性時，會按照ref的屬性值來設定從哪個集合取文件，而系統也根據type來指定從該集合中的文件取哪一個屬性值/path來替代目前所在集合中的每個文件下的屬性值/path

2. 舉例來說，假設有兩個Model分別為Person和Story，person model 中的stories內設定了Schema.Types.ObjectId和ref，由於設定ref來指名要從Story這model來執行populate，而type是Schema.Types.ObjectId且指定要從Story那集合取出ObjectId並填入person中的stories內，形成一個陣列

```
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: String,
  age: Number,
  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]
});

const storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: 'Person' },
  title: String,
  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
});

const Story = mongoose.model('Story', storySchema);
const Person = mongoose.model('Person', personSchema);
```



