---
sidebar_position: 47
---

# u109 新知和技術 

## 註冊表單驗證與錯誤訊息

### 安裝並設定 Flash Message
在這裏會使用connect-flash套件來實現，其套件會依賴著Express-session套件或者Session機制來實作，所以必須先安裝Express-session來讓伺服器建立Session去讓瀏覽器對應資料。
1. 安裝connect-flash套件和Express-session套件
```
npm install express-session@1.17.2 connect-flash@0.1.1
```


### 設置套件
1. 分別於app.js設定express-session套件以及connect-flash套件
```
const express = require('express')
const handlebars = require('express-handlebars')

// 載入flase、session套件
const flash = require('connect-flash')
const session = require('express-session')


require('./models')

const routes = require('./routes')

// 設定SESSION_SECRET
const SESSION_SECRET = 'secret'

const app = express()
const port = process.env.PORT || 3000

app.engine('hbs', handlebars({ extname: '.hbs' }))
app.set('view engine', '.hbs')

app.use(express.urlencoded({ extended: true }))

// 啟用express-session套件設定
// 主要定義伺服器與客戶端進行連線時所要用的設定，分別為如下：
// 簽署用密鑰
// saveUninitialized: 是否儲存未初始化的SESSION
// resave: 是否將未修改的SESSION繼續儲存
app.use(session({
  secret: SESSION_SECRET,
  saveUninitialized: false,
  resave: false
}))

// 啟用connect-flash套件
app.use(flash())


// 根據connect-flash所建立的陣列來取出特定種類陣列內的內容，並分別給同一個middleware stack
// 的區域變數success_messages和error_messages來存取其陣列內容
// 分別為success_messages種類的陣列、error_messages種類的陣列
app.use((req, res, next) => {
  res.locals.success_messages = req.flash('success_messages')
  res.locals.error_messages = req.flash('error_messages')
  next()
})

app.use(routes)

app.listen(port, () => {
  console.info(`Example app listening on port ${port}!`)
})

module.exports = app
```

### 在主樣板裡加入 Flash Message


### 加入表單驗證邏輯


### 建立錯誤處理的 middleware


### 確認結果






表單驗證與錯誤訊息 

```
signUp: (req, res) => {
  const { name, email, password, passwordCheck } = req.body

  
    if (password !== passwordCheck) throw new Error('Passwords do not match!')
    User.findOne({ email })
      .then(user => {
        if (user) throw new Error('Email already exists!')
        bcrypt.hash(password, 10)
          .then(password =>
            User.create({
              name,
              email,
              password
            })
          )
      })
      .then(() => res.redirect('/users/signin'))
  }
```

改良版本：將所有then平鋪成同一層(由上至下來看)以維持維護性以及可讀性
改良點為
	1. 將內層的bcrypt.then移到外層
  2. bcrypt.hash維持原地，並改成return bcrypt.hash，讓原本的bcrypt.then能夠接收到

```
 signUp: (req, res, next) => {
    const { name, email, password, passwordCheck } = req.body

    if (password !== passwordCheck) throw new Error('Passwords do not match!')

    User.findOne({ where: { email } })
      .then(user => {
        if (user) throw new Error('Email already exists!')
        return bcrypt.hash(password, 10)
      })
      .then(password =>
        User.create({
          name,
          email,
          password
        })
      )
      .then(() => {
        req.flash('success_messages', '成功註冊帳號！')
        res.redirect('/users/signin')
      })
      .catch(error => {
        next(error)
      })
  }

}
```


建立一個middleware 能夠一般常見的處理錯誤

```
 mkdir middleware
$ touch middleware/error-handler.js
```

該middleware內容會假定夾雜錯誤訊息的東西為物件或者非物件，若是物件的話，勢必會被定義為擁有name和message這兩個屬性的物件，若不是物件，就只是單純訊息內容，接著利用其內容來設定flash-message，最後透過res.redirect強制瀏覽器轉向上一頁，並重新讀取flash-message來渲染該訊息。除此之外，最後一行的next(err)是將err遞移給下一個錯誤處理，預設上來說，express本身也會有錯誤處理的middleware，若是沒添加next(err)，就不會觸發到

```
module.exports = {
  generalErrorHandler (err, req, res, next) {
    if (err instanceof Error) {

      req.flash('error_messages', `${err.name}: ${err.message}`)
    } else {
      req.flash('error_messages', `${err}`)
    }
    res.redirect('back')
    next(err)
  }
}
```


這段程式碼：
* 首先判斷傳入的 err 是不是一個 Error 物件
    * 如果是，Error 物件裡面會有屬性 name 和 message，那麼我們利用快閃訊息把值印出來給使用者看
    * 如果不是 Error 物件，可能傳進來的一堆錯誤報告，直接把字串印出來即可
* res.redirect('back')：把使用者導回錯誤發生的前一頁 。因為使用者是從前一頁來的，表示前一頁應該是沒問題。
* next(err)：把 Error 物件傳給下一個error handler。


A back redirection redirects the request back to the referer, defaulting to / when the referer is missing.
```
res.redirect('back')
```



express 會自動接收error並按照預設的錯誤處理來進行

> Errors that occur in synchronous code inside route handlers and middleware require no extra work. If synchronous code throws an error, then Express will catch and process it. For example:

```
app.get('/', function (req, res) {
  throw new Error('BROKEN') // Express will catch this on its own.
})
```

Express 會自動執行next(error)，並遞移給預設錯誤處理的middleware





你可能覺得很奇怪，前一行把使用者導回「回到上一頁」了，為什麼還要繼續把 err 傳下去？可以做什麼？ 其實教案這裡只先示範了一個最基本的通用款 error handler 寫法。在更正規的開發程序中，會再細分錯誤的類型 Error Handler，例如：資料庫出錯、伺服器運作錯誤、網路連線失敗...等狀況，一個一個往下判斷接到的錯誤是哪種類型、要做哪些對應的處理或提示。所以 err 傳下去可以做為伺服器運作錯誤的 log，或是其他用途，雖然我們的專案不會用到，先幫大家開啟未來的想像。




設定路由
```
請到 routes/index.js 加入剛剛做好的 error handler：
const restController = require('../controllers/restaurant-controller')
const userController = require('../controllers/user-controller')
const { generalErrorHandler } = require('../middleware/error-handler') // 加入這行
router.use('/admin', admin)
router.get('/signup', userController.signUpPage)
router.post('/signup', userController.signUp)
router.get('/restaurants', restController.getRestaurants)
router.get('/', (req, res) => res.redirect('/restaurants'))

// 加入至這行，是為了集中處理上面路由的錯誤處理至這
router.use('/', generalErrorHandler)  // 加入這行
module.exports = router
```