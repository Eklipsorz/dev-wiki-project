---
sidebar_position: 76
---

# u151 新知和技術


## 依分類篩選餐廳總表
需求： 在所有的餐廳名單中，挑出類別為義大利餐廳的餐廳列表

在這裡你可能會馬上想到兩種路由設計方式，請你先花三分鐘想想，以下兩種路由設計有什麼差別，而現在的情境適合選用哪種？
```
/restaurants?categoryId=3
/categories/:id
```


在這裡我們會選擇用第一種路由 /restaurants?categoryId=3。

理由還是回歸到 RESTful 的精神，設計出能直觀反映路徑的路由。

第一種路由 /restaurants?categoryId=3 意指：「在所有的餐廳名單中，挑出類別為義大利餐廳的餐廳列表。」也就是我們的需求情境。
第二種路由 /categories/:id 則是指說：「從 /categories 這個頁面，進入義大利餐廳這個類別。」
第二種路由的情境，通常會是在規模較大、資料量較繁雜的網頁，例如新聞網站，它有專門的 /categories 頁面，使用者可從中點選不同的分類，像是進入國際時事類別、科技時事類別...等等。

不過我們此處沒有這樣的資料量需求，也沒有開設 /categories 頁面，我們的需求是「在所有的餐廳名單中，挑出類別為義大利餐廳的餐廳列表。」因此這裡會選用 /restaurants?categoryId=3。



請於 views/restaurants.hbs 的最上方加入導覽器，第一個項目留給「全部餐廳」的情境，之後就迭代 categories 變數，取出分類名稱的同時，把 id 加到網址上，之後就可以在 controller 裡拿到參數：

於views/restaurants.hbs上方建立一個導覽器，這個導覽器充滿著許多選項來讓使用者選擇特定餐廳類別下的餐廳，在這裏的功能設計上會滿足如下規則
  - 只會允許一個選項表現岀被點選的樣式
  - 當使用者未點選任何選項，就讓代表"全部"這選項表現出active的樣式
  - 當使用者點選任何選項，除了該選項表示active樣式以外，其餘選項都不予表現出來


為了達到這點，就利用ifCond和Query String之間的關係來實現，當沒有選擇任何類別時，categoryId就會因為
其變數值在Query String表現出空值而顯示為空值，那麼就預設代表"全部"的選項呈現成active樣式，而其他選項則因為categoryId是空值，所以不會跟著呈現active。而若使用者點選除了代表"全部"選項以外的選項的話，則會因為categoryId是特定類別的id，而使代表"全部"選項以及跟id不同的選項皆為inactive樣式，只有與該id相符的選項才會表現出active，而這個選項也只有一個。
```
<ul class="nav nav-pills">
  <li class="nav-item">
    <a class="nav-link {{#ifCond '' categoryId}}active{{/ifCond}}" href="?categoryId=">全部</a>
  </li>
  {{#each categories}}
    <li class="nav-item">
      <a class="nav-link {{#ifCond this.id ../categoryId}}active{{/ifCond}}"
        href="?categoryId={{this.id}}">{{this.name}}</a>
    </li>
  {{/each}}
</ul>
```



調整controller
這裡出現一個比較棘手的問題，當使用者點選的是「全部」這個頁籤時，categoryId 會是空值。也就是說，在設定 where 查詢條件時，若要撈出全部，需要：

1. where: {}，或者
2. 連 where 這個 key 都不要設定
根據上述想法，我們更新 controller 如下：

```
getRestaurants: (req, res, next) => {
    const categoryId = Number(req.query.categoryId) || ''
    const where = {}
    if (categoryId) where.categoryId = categoryId

    return Promise.all([
      Category.findAll({ raw: true }),
      Restaurant.findAll({ raw: true, nest: true, where, include: [Category] })
    ])
      .then(([categories, restaurants]) => {
        restaurants.map(r => ({
          ...r,
          description: r.description.substring(0, 50)
        }))
        return res.render('restaurants', { restaurants, categories, categoryId })
      })
      .catch(error => next(error))
  }

```