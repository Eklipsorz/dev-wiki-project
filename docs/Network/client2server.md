---
sidebar_position: 1
---


# HTTP：客戶端如何對伺服器發送請求

HTTP協定通常運用於網頁呈現以及網頁處理，當使用者只要在瀏覽器輸入URL來指定向哪個(伺服器)主機發送請求以及要索取什麼樣的資源，而瀏覽器就作為使用者的代理人來成為客戶端向伺服器發送索取資源，而伺服器端則是能夠回應客戶端的資源存取請求並回傳對應資料的主機，最後瀏覽器收到伺服器的回應時便會根據回應內容來渲染畫面。然而這兩者間的資料傳遞形式會隨著時間而不斷迭代，從單純傳送和接收到以模組化來進行的形式，每一種迭代都在往前一次所發生的問題而進行，在這本文章中會討論從單純傳送和接收到以模組化來進行之間的變化。



## 請求處理模型
### 早期的架構

一開始瀏覽器會單純作為客戶端來對伺服器發送索取資源的請求，而伺服器收到請求後，便會從伺服器內部的資料庫來找客戶端想要的資料，當找到資料後便會直接用這些資料來更新伺服器內部存放的HTML、CSS、JS檔案，並且將這些檔案以封包的形式回傳給客戶端，而客戶端收到回應內容時便會根據HTML、CSS、JS檔案來渲染畫面給使用者看以及互動。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/simpleModel_hnh2nh.png)


### 重新定義伺服器架構

與早期的資料傳遞結構不同，為了讓伺服器的網頁開發更好地被管理及維護，從而分離出負責回應客戶端的伺服器以及負責儲存資料的伺服器，而伺服器本身則是按照功能分出三個主要區塊，分別為負責與資料庫以及資料管理的模型(Model)、負責產生出能夠在瀏覽器進行視覺呈現的HTML、CSS、JS檔案的視圖(View)，負責與客戶端接洽(接收請求和回應請求)並且與Model、View相互合作完成客戶端所要求的請求的控制器(controller)，而這些區塊的分出被合稱之為 MVC (Model-View-Controller)，在這裏的控制器由於本身是需要在伺服器一收到請求時就要攔截到客戶端請求並且與Model、View進行適當的對應，但客戶端的請求多半是需要定義哪種請求是正確的以及錯誤的並以此當做標準去篩選請求是不是錯誤的請求、正確的請求該如何做轉發、錯誤的請求又該如何去做，那麼這個功能是否要合併至controller？還是獨立出一個區塊負責？

在這裏，常見的做法是後者，建立一個路由系統(Routing System)來負責請求篩選、轉發，當這個路由系統判定請求是錯誤的話，會直接跳出404或者錯誤的話；而當這個路由系統判定請求是正確的話，會直接將請求轉發至對應的controller進行後續的處理。由於會判定請求是否錯誤，判定的基準並非限定於真實檔案名稱是否存在，而是依照開發者對於路由系統所定下的標準，所以可以定義一些具有意義的請求名稱來幫助開發以及使用者知道這請求是做什麼，比如說在路由系統推出之前，若我想提供todolist這功能，但實際上能呈現的網頁是在/path之下的todolist.html，所以瀏覽器的URL必須依照下面的第一行來打才能呈現，而若有路由系統，就直接輸入在網址之後添加todolist就行，如同下面第二行，當路由系統收到這請求，會直接轉發相關的controller來以/path/todolist.html的內容進行呈現。
```
https://test.com/path/todolist.html
https://test.com/todolist
```
每當瀏覽器發送一個符合路由系統規則的請求時，伺服器上的路由系統將會根據請求名稱來轉接到適當的controller來進行後續的處理，

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_dgvnhm.png)

整體而言的話，當客戶端在自身的瀏覽器上輸入URL並獲取對應的IP重新發送(如上圖中的第一步驟)時，而URL中表示索要的資源格式會滿足於伺服器的路由系統所定下的規則，接著伺服器的路由系統來接收這請求並將請求轉發給對應的Controller(如上圖中的第二步驟)，由它處理後續的請求，首先它會先從負責管理資料的model來請求資料(如上圖中的第三步驟)，讓model去單方面存取資料庫的系統並讓它回傳使用者想要存取的資料給model(如上圖中的第四～五步驟)，再由model轉發資料給controller(如下圖中的第六步驟)，接著再利用這些資料來更新伺服器內部存放的HTML、CSS、JS檔案，然後由view回傳到controller(如上圖中的第七～八步驟)，最後讓controller去回傳其對應這些檔案給客戶端(如下圖中的第九步驟)，讓客戶端(瀏覽器)根據內容來渲染一次畫面給使用者。

然而由於這個架構下的請求和回應皆受限於伺服器端，而伺服器本身內部存放一個樣板網站(由HTML、CSS、JS所構成)來讓伺服器對於請求來為這個網站修改內容，所以當瀏覽器需要做些內容更新上的渲染時，都要重新發送請求給伺服器端，而伺服器又會從資料獲取資料並填入這個樣板，最後再將填入後的樣板回傳瀏覽器，每一次一小部分的更新都會因為樣板被固定的關係只能整份網頁都更換。


### AJAX的出現

然而，由於上個架構下的請求和回應皆受限於伺服器端，而伺服器本身內部存放一個樣板網站(由HTML、CSS、JS所構成)來讓伺服器對於請求來為這個網站修改內容，所以當瀏覽器需要做些內容更新上的渲染時，都要重新發送請求給伺服器端，而伺服器又會從資料獲取資料並填入這個樣板，最後再將填入後的樣板回傳瀏覽器，每一次一小部分的更新都會因為樣板被固定的關係只能整份網頁都更換。

隨後，為了解決這問題，就有人想著若可以從客戶端的角度來更新向伺服器索求資訊來更新部分內容以及在更新的同時間不能夠影響著使用者的使用體驗，說不定能避免上述的問題，所以就有人為瀏覽器提供AJAX(Asynchronous JavaScript and XML)這功能，這功能能讓瀏覽器以非同步的形式去向伺服器索求瀏覽器(使用者想要)的資訊，並讓伺服器回傳這些資訊，而客戶端會利用AJAX來接收這資訊並且做出適當的部分內容渲染，而非整份文件的渲染，在這個架構之下，伺服器中的View將轉移至客戶端來進行，然後由客戶端的AJAX去根據需求像伺服器索要資料並於瀏覽器進行渲染。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_moveView2Browser_tlhh6y.png)

不過當瀏覽器還未取得完整的網頁時，還是會像下圖中那樣去索求完整的網頁檔案，等到完全取得並渲染完成的時候，便會以AJAX為主的架構進行更新。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_dgvnhm.png)

### 前端框架的出現

不過AJAX本身並不是一個完美的技術，還是會出現意想不到的問題，由於AJAX本身會是非同步的運作，而AJAX本身利用其特色來獲取資料，但隨之而來的是對於獲取到資料所要做的網頁更新也會是非同步進行，而這種非同步的運作中，我們無法確定請求什麼時候傳送、什麼時候會收到請求、什麼時候會利用請求來渲染畫面，所以很有可能會因這無法確定而讓結果不如預期。所以就為了解決這不確定的問題，就有人提出Vue.js、React.js等前端框架來解決，由框架中的某一塊利用AJAX來更新網站的部分內容。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_framework_abzxcz.png)


不過當瀏覽器還未取得完整的網頁時，還是會像下圖中那樣去索求完整的網頁檔案，等到完全取得並渲染完成的時候，便會以前端框架為主的架構進行更新。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_dgvnhm.png)


## Protocol
1. 從中文翻譯來是指一種能讓參與者接受並遵守的正式規範條例或者規範
2. 時常引申至電腦之間的網路連線，就是讓電腦們對於要連接傳遞封包所要遵守的規範或者正式規範條例，目的在於能夠統一不同種類的電腦能在傳遞封包這件事情上能有一樣的共識、一樣的處理方式。


## Frame
1. 中文翻譯為維持物件的框架，在這裡指的是資料鏈結層所能接受的資料格式-訊框、MAC 訊框、MAC
2. 當封包從網路層轉遞至資料鏈結層時，會實際把封包內容放置訊框中的乘載量(Payload)，並由Header和CRC在封包的前後兩端來構成訊框，該乘載量最大能放1500bytes，所以能放的封包大小最多只能是1500bytes，所以
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633538606/blog/network/networkModel/macFrame_zpxt1t.png)

3. 訊框會直接能夠被實體層變轉化成位元串，而位元串



## Packet 
1. 中文翻譯是指用紙包裝的物件，其詞運用至電腦網路上如何封裝資料以及資料傳遞形式，而此形式只會在資料鏈結層以上的階層進行資料上的表達，
2. 如同字面上的意思，物件是指需要經過傳遞的資料，而用紙包裝是指標頭(Header)，所以一個封包由標頭(header)和內容(payload)所組成，而封包數量和大小會因為最後要被塞入至Frame而被分割，而Frame大小最多只能放1500 bytes，所以基本上封包大小若超過1500bytes的話，會根據1500bytes來切割出好幾等分的封包，而每個封包最大到1500bytes。
3. 當經過網路模型不斷封裝時，其封包的本質仍然不變，但直到經過資料鏈結層時，便不能夠稱之為封包，因為會被轉化為Frame。

## Router
1. 實現透過網路層所給予的定址以及路由決定功能的機器，負責進行封包傳遞的轉發和路由功能
2. 當封包要傳遞另一個網路的主機時，可以透過路由器來來轉送至離那台主機較近的路由器，接著再透過其路由器尋找更近，直到找到與那主機同在相同網路的路由器，到那時就能直接透過該路由器來轉發封包


## Client & Server
1. 當發生資料傳遞時，肯定會出現兩台實體主機，其中發送要求的主機被稱之為client，而回應請求並給予服務的主機被稱之為server


## IP
1. 是網路層的IP協定(Internet Protocol)，該協定主要定址虛擬網路位址，而其位址被稱之為IP Address或者IP

## HTTP
1. 一種主機之間互相索取超文件的協定或者溝通語言

## TCP
1. 全名為Transmission Control Protocol，傳輸控制協定
2. 具有以下目的來提供相關功能，第一個目的是確認server和client這兩端的傳送和接收功能都是正常的，第二個目的就是避免由過舊重複的封包而引發的混亂問題，白話一點確定一切傳送接收都沒問題，只要沒問題就能直接開始傳遞封包