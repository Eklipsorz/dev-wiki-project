---
sidebar_position: 1
---


# HTTP：客戶端如何對伺服器發送請求

HTTP協定通常運用於網頁呈現以及網頁處理，當使用者只要在瀏覽器輸入URL來指定向哪個(伺服器)主機發送請求以及要索取什麼樣的資源，而瀏覽器就作為使用者的代理人來成為客戶端向伺服器發送索取資源，而伺服器端則是能夠回應客戶端的資源存取請求並回傳對應資料的主機，最後瀏覽器收到伺服器的回應時便會根據回應內容來渲染畫面。然而這兩者間的資料傳遞形式會隨著時間而不斷迭代，從單純傳送和接收到以模組化來進行的形式，每一種迭代都在往前一次所發生的問題而進行，在這本文章中會討論從單純傳送和接收到以模組化來進行之間的變化。

## 早期

一開始瀏覽器會單純作為客戶端來對伺服器發送索取資源的請求，而伺服器收到請求後，便會從伺服器內部的資料庫來找客戶端想要的資料，當找到資料後便會直接用這些資料來更新伺服器內部存放的HTML、CSS、JS檔案，並且將這些檔案以封包的形式回傳給客戶端，而客戶端收到回應內容時便會根據HTML、CSS、JS檔案來渲染畫面給使用者看以及互動。

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/simpleModel_hnh2nh.png)


## 伺服器架構



當客戶端在自身的瀏覽器上輸入URL時，就等同向伺服器索要對應網頁之原始碼或者資源的請求給伺服器(如下圖中的第一步驟)，但若URL上的伺服器對應位址是用域名的話，會先試著透過瀏覽器、客戶端作業系統、路由器、ISP、DNS伺服器找到對應URL的IP，並重新以IP來發送請送請求(如下圖中的第一步驟)，接著會伺服器的路由系統來接收這請求並將請求轉發給Controller(如下圖中的第二步驟)，由它處理後續的請求，首先它會先從負責管理資料的model來請求資料(如下圖中的第三步驟)，讓model去單方面存取資料庫的系統並讓它回傳使用者想要存取的資料給model(如下圖中的第四～五步驟)，再由model轉發資料給controller(如下圖中的第六步驟)，接著再利用這些資料來渲染，這部分會去找負責這塊
的View並重新將資料配置至網頁內容中(如下圖中的第七～八步驟)，最後由view回傳到controller，讓controller去回傳其對應網頁以及資源給客戶端(如下圖中的第九步驟)


![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633596645/blog/network/ClientAndServer/MVCModel_dgvnhm.png)

，會透過DNS對應IP來將對應伺服器URL轉換成IP，接著再透過IP來找到伺服器，接著發送要求至伺服器來要求對應路由的網頁，接著伺服器的controller部分會接收客戶端的請求並將對應資料從資料庫撈出來對應至伺服器上的view區塊中先將要給予使用者的網頁進行（資料上的對應和渲染），最後再把網頁以封包的形式傳遞至客戶端，隨後客戶端的瀏覽器再把網頁進行解析以及渲染，

當客戶端需要從伺服器獲取資料時，便會利用對應路由從伺服器端獲取資料並讓其回傳資料並於自身瀏覽器進行渲染或著由伺服器回傳帶有對應資料的網頁（也就是由伺服器利用客戶想要的資料進行網頁的改造並回傳之）

## AJAX的出現


## 前端框架的出現



基本問題：
1. Protocol、packet、router、IP、TCP、HTTP、Client & Server端是什麼
2. 它們能做些什麼？
3. 你能夠用他們做什麼？
4. 資料為什麼可以成功傳輸到目的地？(以現有平台提供的線索來回答)
5. 設備之間究竟為什麼能互相溝通


## Protocol
1. 從中文翻譯來是指一種能讓參與者接受並遵守的正式規範條例或者規範
2. 時常引申至電腦之間的網路連線，就是讓電腦們對於要連接傳遞封包所要遵守的規範或者正式規範條例，目的在於能夠統一不同種類的電腦能在傳遞封包這件事情上能有一樣的共識、一樣的處理方式。


## Frame
1. 中文翻譯為維持物件的框架，在這裡指的是資料鏈結層所能接受的資料格式-訊框、MAC 訊框、MAC
2. 當封包從網路層轉遞至資料鏈結層時，會實際把封包內容放置訊框中的乘載量(Payload)，並由Header和CRC在封包的前後兩端來構成訊框，該乘載量最大能放1500bytes，所以能放的封包大小最多只能是1500bytes，所以
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633538606/blog/network/networkModel/macFrame_zpxt1t.png)

3. 訊框會直接能夠被實體層變轉化成位元串，而位元串





## Packet 
1. 中文翻譯是指用紙包裝的物件，其詞運用至電腦網路上如何封裝資料以及資料傳遞形式，而此形式只會在資料鏈結層以上的階層進行資料上的表達，
2. 如同字面上的意思，物件是指需要經過傳遞的資料，而用紙包裝是指標頭(Header)，所以一個封包由標頭(header)和內容(payload)所組成，而封包數量和大小會因為最後要被塞入至Frame而被分割，而Frame大小最多只能放1500 bytes，所以基本上封包大小若超過1500bytes的話，會根據1500bytes來切割出好幾等分的封包，而每個封包最大到1500bytes。
3. 當經過網路模型不斷封裝時，其封包的本質仍然不變，但直到經過資料鏈結層時，便不能夠稱之為封包，因為會被轉化為Frame。

## Router
1. 實現透過網路層所給予的定址以及路由決定功能的機器，負責進行封包傳遞的轉發和路由功能
2. 當封包要傳遞另一個網路的主機時，可以透過路由器來來轉送至離那台主機較近的路由器，接著再透過其路由器尋找更近，直到找到與那主機同在相同網路的路由器，到那時就能直接透過該路由器來轉發封包


## Client & Server
1. 當發生資料傳遞時，肯定會出現兩台實體主機，其中發送要求的主機被稱之為client，而回應請求並給予服務的主機被稱之為server


## IP
1. 是網路層的IP協定(Internet Protocol)，該協定主要定址虛擬網路位址，而其位址被稱之為IP Address或者IP

## HTTP
1. 一種主機之間互相索取超文件的協定或者溝通語言

## TCP
1. 全名為Transmission Control Protocol，傳輸控制協定
2. 具有以下目的來提供相關功能，第一個目的是確認server和client這兩端的傳送和接收功能都是正常的，第二個目的就是避免由過舊重複的封包而引發的混亂問題，白話一點確定一切傳送接收都沒問題，只要沒問題就能直接開始傳遞封包